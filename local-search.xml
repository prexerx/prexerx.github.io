<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>在内网快速利用docker搭建DNS服务器</title>
    <link href="/2020/10/29/docker/internal_dns_server_setup/"/>
    <url>/2020/10/29/docker/internal_dns_server_setup/</url>
    
    <content type="html"><![CDATA[<div class="note note-light">            <p>如果你还犯愁，如何在内网搭建DNS服务器，那么请看看这里吧。</p>          </div><a id="more"></a><h2 id="当前主机是否已经启用53端口？"><a href="#当前主机是否已经启用53端口？" class="headerlink" title="当前主机是否已经启用53端口？"></a>当前主机是否已经启用53端口？</h2><p>如果你不清楚53端口的功能，请查看下<code>/etc/services</code>文件，它会告诉你答案。</p><p>为了顺利进行下一步，需要确保你的机器上没有开启53端口，也就是说你的主机不是一个DNS Server。</p><p>如何确定呢？当然要使用<code>netstat命令</code>来查看端口，当然配合<code>lsof命令</code>也许会更明确。</p><p>比如笔者本机就是这样的：</p><pre><code class="hljs shell">prexer $ netstat -ntulp | grep 53(Not all processes could be identified, non-owned process info will not be shown, you would have to be root to see it all.)tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      -udp        0      0 127.0.0.53:53           0.0.0.0:*                           -udp        0      0 0.0.0.0:5353            0.0.0.0:*                           -udp6       0      0 :::5353                 :::*                                -prexer $ sudo lsof -i:53COMMAND   PID            USER   FD   TYPE DEVICE SIZE/OFF NODE NAMEsystemd-r 778 systemd-resolve   12u  IPv4  20918      0t0  UDP localhost:domainsystemd-r 778 systemd-resolve   13u  IPv4  20919      0t0  TCP localhost:domain (LISTEN)</code></pre><p>如果找到了端口占用，只要关闭指定的程序即可，简单来说就是这样：</p><pre><code class="hljs livecodeserver">prexer $ sudo systemctl <span class="hljs-built_in">stop</span> systemd-<span class="hljs-built_in">resolve</span><span class="hljs-comment"># 或者</span>prexer $ sudo <span class="hljs-built_in">kill</span> your_pid</code></pre><h2 id="用什么来构建DNS服务器呢？"><a href="#用什么来构建DNS服务器呢？" class="headerlink" title="用什么来构建DNS服务器呢？"></a>用什么来构建DNS服务器呢？</h2><p>当然是大名鼎鼎的<code>DNSmasq</code>了，如果你不了解，您这边请: <a href="http://www.thekelleys.org.uk/dnsmasq/doc.html%E3%80%82">http://www.thekelleys.org.uk/dnsmasq/doc.html。</a></p><p>这个项目是有命令行支持的，参考官网也可以很容易构建出来，不过本文打算使用更见到的docker容器来完成这件事。</p><p>说到这里，请注意，本文并没有直接使用官方提供的docker镜像，而是使用了另一个拥有web支持的docker镜像。</p><ul><li><p>官方镜像在<a href="https://hub.docker.com/r/andyshinn/dnsmasq/">这里</a></p></li><li><p>有web支持的镜像在<a href="https://github.com/jpillora/docker-dnsmasq">这里</a></p></li></ul><h2 id="构建一个符合你胃口的DNSmasq的配置文件"><a href="#构建一个符合你胃口的DNSmasq的配置文件" class="headerlink" title="构建一个符合你胃口的DNSmasq的配置文件"></a>构建一个符合你胃口的DNSmasq的配置文件</h2><p>对于配置docker镜像而言，配置文件肯定是逃不了的，你可以先看看<a href="http://oss.segetech.com/intra/srv/dnsmasq.conf">官方的配置文档</a>，了解有什么后，再动手也不迟。</p><p>这里我们介绍一个通用且简单的配置，当你学完后可以自己进行修改，多开心。</p><p>配置文件及解释如下：(将这个文件保存为：dnsmasq.conf文件，存储在你当前的工作目录或者任意可指定的目录即可)</p><pre><code class="hljs routeros"><span class="hljs-comment"># filename: dnsmasq.conf</span><span class="hljs-comment"># 需要存储log，后续再命令行中指定log的限制大小</span>log-queries<span class="hljs-comment"># 指定一个自定义的解析文件，它可以保证你不用修改原始的配置文件/etc/resolv.conf</span><span class="hljs-attribute">resolv-file</span>=/tmp/resolv.conf<span class="hljs-comment"># 一个测试的名字，IP地址是内部网络的另一台主机，通过这个名字来完成后续的验证</span><span class="hljs-attribute">address</span>=/hello.remote/10.22.52.229<span class="hljs-comment"># upstream nameserver，也就是找不到靠上游的道理</span><span class="hljs-comment"># server=/localnet/127.0.0.1 # 不加也可以，添加非公开的内网DNS，就像联机打游戏一样 </span><span class="hljs-attribute">server</span>=10.22.0.1<span class="hljs-attribute">server</span>=10.22.0.2</code></pre><p>复制一份解析文件：</p><pre><code class="hljs shell">prexer $ sudo cp /etc/resolv.conf /tmp/resolv.conf</code></pre><p>到了这里，基本的配置就算完成了，很简单吧，之后我们开始启动DNSmasq容器。</p><h2 id="开始构建激动人心的docker容器"><a href="#开始构建激动人心的docker容器" class="headerlink" title="开始构建激动人心的docker容器"></a>开始构建激动人心的docker容器</h2><p>众所周知，容器的使用廉价的可怜，所以你几乎不用知道细节就可以搭建一个完美的沙盒环境（一点不知道也不行哈…)。按照官方文档的指示，你当然可以修改docker启动的参数，然后鼓捣鼓捣自己的配置，反正玩不坏，尽情尝试。不过为了教学，请看看我的例子：</p><pre><code class="hljs shell">docker run -d\    --name dnsmasq \    --rm \    -p 53:53/udp \    -p 53:53/tcp \    -p 8080:8080 \    -v `pwd`/dnsmasq.conf:/etc/dnsmasq.conf \    --log-opt &quot;max-size=100m&quot; \    -e &quot;HTTP_USER=root&quot; \    -e &quot;HTTP_PASS=root&quot; \    jpillora/dnsmasq</code></pre><p>一些简单的参数解释：</p><pre><code class="hljs livescript">docker run -d<span class="hljs-string">\</span> <span class="hljs-comment"># 以守护进程的方式运行容器</span>    --name dnsmasq <span class="hljs-string">\</span> <span class="hljs-comment"># 容器的名字</span>    --rm <span class="hljs-string">\</span> <span class="hljs-comment"># 用完后删除，即你stop的时候就会删除哦</span>    -p <span class="hljs-number">53</span>:<span class="hljs-number">53</span>/udp <span class="hljs-string">\</span> <span class="hljs-comment"># 暴露容器的53端口和宿主机关联，udp/tcp协议如果你不懂，简单百科一下</span>    -p <span class="hljs-number">53</span>:<span class="hljs-number">53</span>/tcp <span class="hljs-string">\</span>    -p <span class="hljs-number">8080</span>:<span class="hljs-number">8080</span> <span class="hljs-string">\</span> <span class="hljs-comment"># 暴露容器的web端口，便于后续再网页上查看和配置</span>    -v `pwd`/dnsmasq.conf:/etc/dnsmasq.conf <span class="hljs-string">\</span> <span class="hljs-comment"># 重点，配置文件的关联，这个逻辑卷的知识你可以自行科普</span>    --log-opt <span class="hljs-string">&quot;max-size=100m&quot;</span> <span class="hljs-string">\</span> <span class="hljs-comment"># 限制输出的log文件的大小，很简单是吧，呼应前文</span>    -e <span class="hljs-string">&quot;HTTP_USER=root&quot;</span> <span class="hljs-string">\</span> <span class="hljs-comment"># 登录web的用户名和密码</span>    -e <span class="hljs-string">&quot;HTTP_PASS=root&quot;</span> <span class="hljs-string">\</span>    jpillora/dnsmasq <span class="hljs-comment"># 包含web的基础dnsmasq镜像</span></code></pre><p>查看启动状态，只是一些基础的docker指令：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> &gt; docker ps -a |grep dnsmasq <span class="hljs-comment"># 看容器的启动状态</span></span>prexer $ docker ps -a|grep dnsmasq6d75bfc34244        jpillora/dnsmasq                       &quot;webproc --config /e…&quot;   18 seconds ago      Up 17 seconds       0.0.0.0:53-&gt;53/tcp, 0.0.0.0:8080-&gt;8080/tcp, 0.0.0.0:53-&gt;53/udp   dnsmasq<span class="hljs-meta">#</span><span class="bash"> &gt; docker logs -f dnsmasq <span class="hljs-comment"># 看容器的标准输出log</span></span>prexer $ docker logs -f dnsmasq[webproc] 2020/10/30 00:37:30 loaded config files changes from disk[webproc] 2020/10/30 00:37:30 agent listening on http://0.0.0.0:8080...dnsmasq: started, version 2.80 cachesize 150dnsmasq: compile time options: IPv6 GNU-getopt no-DBus no-i18n no-IDN DHCP DHCPv6 no-Lua TFTP no-conntrack ipset auth no-DNSSEC loop-detect inotify dumpfilednsmasq: using nameserver 10.22.0.2#53dnsmasq: using nameserver 10.22.0.1#53dnsmasq: read /etc/hosts - 7 addresses</code></pre><p>至于是否启动成功，看看输出结果，对比对比就成了。</p><h2 id="来吧，一起可视化查看与验证"><a href="#来吧，一起可视化查看与验证" class="headerlink" title="来吧，一起可视化查看与验证"></a>来吧，一起可视化查看与验证</h2><p>从浏览器登录你已经配置的主机，方法如下：</p><pre><code class="hljs awk">在浏览器中输入：http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8080</span> 或者 http:<span class="hljs-regexp">//</span>remote_ip_address:<span class="hljs-number">8080</span></code></pre><p>这样就能到达登录界面，用户名和密码是之前命令行参数中配置的，请自行填写，效果如下：</p><p><img src="/img/blog-images/dns_web_show.png" alt="login web"></p><p>登录后的界面如下：</p><p><img src="/img/blog-images/dns_web_display.png" alt="display web"></p><p>在验证之前还需要一点知识要梳理：</p><p>首先，之前复制的DNS解析文件<code>/tmp/resolv.conf</code>是配置的DNSmasq解析的上游服务文件，具体请看下面的解释：</p><pre><code class="hljs vala"><span class="hljs-meta"># Change this line if you want dns to get its upstream servers from</span><span class="hljs-meta"># somewhere other that /etc/resolv.conf</span><span class="hljs-meta">#resolv-file=</span></code></pre><p>很多同学在里面配置了<code>nameserver 127.0.0.1</code>本地的地址，想要使用本地的docker DNS服务，其实还不行，需要你真正配置本机的DNS解析文件才可以，也就是修改<code>/etc/resolv.conf</code>添加如下信息：</p><pre><code class="hljs angelscript">nameserver <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span></code></pre><p>到这里基本上可以进行下一步了。</p><p>那么我们验证一下配置的结果吧：</p><p>首先用你们最熟悉的<code>ping</code>指令，走个ICMP协议看看：</p><pre><code class="hljs routeros">prexer $<span class="hljs-built_in"> ping </span>hello.remote -c 3PING hello.remote (10.22.52.229) 56(84) bytes of data.64 bytes <span class="hljs-keyword">from</span> CNSHZ-ED-SVR097.sierrawireless.local (10.22.52.229): <span class="hljs-attribute">icmp_seq</span>=1 <span class="hljs-attribute">ttl</span>=64 <span class="hljs-attribute">time</span>=0.190 ms64 bytes <span class="hljs-keyword">from</span> CNSHZ-ED-SVR097.sierrawireless.local (10.22.52.229): <span class="hljs-attribute">icmp_seq</span>=2 <span class="hljs-attribute">ttl</span>=64 <span class="hljs-attribute">time</span>=0.257 ms64 bytes <span class="hljs-keyword">from</span> CNSHZ-ED-SVR097.sierrawireless.local (10.22.52.229): <span class="hljs-attribute">icmp_seq</span>=3 <span class="hljs-attribute">ttl</span>=64 <span class="hljs-attribute">time</span>=0.230 ms--- hello.remote<span class="hljs-built_in"> ping </span>statistics ---3 packets transmitted, 3 received, 0% packet loss, time 1998msrtt min/avg/max/mdev = 0.190/0.225/0.257/0.032 ms</code></pre><p>在来看看主机的IP地址映射关系，当然要用<code>host</code>指令：</p><pre><code class="hljs routeros">prexer $ host hello.remotehello.remote has<span class="hljs-built_in"> address </span>10.22.52.229</code></pre><p>其他的协议不用一一验证了，应为这是标准的端口，也是通用的tcp/udp协议簇，如果你还好奇，可以验证<code>ssh</code>或者<code>dig</code>之类的指令玩玩。</p><h2 id="内网其他主机如何使用你的DNS服务器？"><a href="#内网其他主机如何使用你的DNS服务器？" class="headerlink" title="内网其他主机如何使用你的DNS服务器？"></a>内网其他主机如何使用你的DNS服务器？</h2><p>本机用当然还不够，要内网其他同事能够使用才行，其实用起来依旧很简单，就是在内网的任意机器上（可达你的主机），修改<code>/etc/resolv.conf</code>文件，添加一行：</p><pre><code class="hljs xml">nameserver <span class="hljs-tag">&lt;<span class="hljs-name">your_dns_server_ip_address</span>&gt;</span></code></pre><p><code>&lt;your_dns_server_ip_address&gt;</code>这个替换你的主机IP就可以了。</p><p>赶快用起来！^_^</p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>dns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>推荐一个加速git仓库下载的方法</title>
    <link href="/2020/10/24/base/git_speed_up_downloading/"/>
    <url>/2020/10/24/base/git_speed_up_downloading/</url>
    
    <content type="html"><![CDATA[<div class="note note-light">            <p>如果访问github限速，那就试试这个方法吧!</p>          </div><a id="more"></a><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>今时已不同往日，网络资源已经逐渐被管控和限制，就当下的形式而言，外网访问的制约，对于一个程序员来说谈不上好事还是坏事。</p><p>不过，如果你在墙内看不到外面的风景，那确实有点可惜，不管是因为墙太高（就像进击的巨人一样）还是其他原因。</p><p>换个法子，将墙外你感兴趣的风景，借助公家条件，移植到墙内来，这样就可以满足你的欲望。</p><p>一样的，github对于国内用户来说已经限速，下载个几十兆的仓库都要好几十分钟，并且有断开的风险，所以请借助gitee达到你的目的吧。</p><h2 id="如何做？"><a href="#如何做？" class="headerlink" title="如何做？"></a>如何做？</h2><p>很简单，利用码云gitee的同步功能，来同步你在github上感兴趣的仓库，然后利用国内极速的网络来完成clone或者下载。</p><h3 id="定位github上的仓库目标"><a href="#定位github上的仓库目标" class="headerlink" title="定位github上的仓库目标"></a>定位github上的仓库目标</h3><p>比如，你在github上看到中了：<a href="https://github.com/hexojs/hexo-starter">https://github.com/hexojs/hexo-starter</a></p><p>那么，请复制这个URL。</p><h3 id="注册并创建gitee仓库"><a href="#注册并创建gitee仓库" class="headerlink" title="注册并创建gitee仓库"></a>注册并创建gitee仓库</h3><p>登录gitee官网：<a href="https://gitee.com/">https://gitee.com/</a></p><p>注册流程交给你自己，就像其他网站注册一样，比较好玩的是国内的gitee可使用手机号绑定并登陆。</p><p>找到并点击<code>新建仓库</code>，然后拖到最后，点击<code>导入仓库</code>，并填写刚才复制的URL地址。</p><p>gitee会自动帮你填充仓库的信息，当然你也可自己修改感兴趣的部分。</p><p>最后点击<code>创建</code>，好了，完成。</p><h3 id="使用gitee"><a href="#使用gitee" class="headerlink" title="使用gitee"></a>使用gitee</h3><p>gitee的用法和github一样，并不特殊，你只需要换一个URL地址。</p><p>从以前的：<br><code>git clone https://github.com/hexojs/hexo-starter.git</code></p><p>到现在的：<br><code>git clone https://gitee.com/prexer/hexo-starter.git</code></p><p>享受极速服务的感觉很不错吧？^_^</p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>gitee</tag>
      
      <tag>github</tag>
      
      <tag>git加速</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文章编写规范</title>
    <link href="/2020/02/20/articles_writing_rules/"/>
    <url>/2020/02/20/articles_writing_rules/</url>
    
    <content type="html"><![CDATA[<div class="note note-light">            <p>本站文章书写规范参考指南。</p>          </div><a id="more"></a><p>文章开头类似如下的语法：</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">xxx</span><span class="hljs-attr">date:</span>  <span class="hljs-string">xxx</span><span class="hljs-attr">categories:</span> <span class="hljs-string">xxx</span><span class="hljs-string">tags：</span> <span class="hljs-string">xxx</span><span class="hljs-attr">layout:</span> <span class="hljs-string">xxx</span><span class="hljs-meta">---</span></code></pre><p>在Hexo中叫做<code>Front-Matter</code>，通过它你可以限定文章的一些行为。</p><p>所以本文重点说明Hexo的<code>Front-Matter</code>和<code>文章书写格式</code></p><h1 id="Front-Matter中必要的信息"><a href="#Front-Matter中必要的信息" class="headerlink" title="Front-Matter中必要的信息"></a>Front-Matter中必要的信息</h1><h2 id="title"><a href="#title" class="headerlink" title="title"></a>title</h2><p>文章标题，内置中文支持</p><h2 id="date"><a href="#date" class="headerlink" title="date"></a>date</h2><p>文章撰写时间</p><h2 id="categories"><a href="#categories" class="headerlink" title="categories"></a>categories</h2><p>文章归档种类，一般认为，<code>categories</code>用来描述文章作者的知识结构树，文章应该明确属于某一个领域，哪怕它已经借鉴了其他领域的知识。</p><h2 id="tags"><a href="#tags" class="headerlink" title="tags"></a>tags</h2><p>文章的标签，一般认为，<code>tags</code>并不和<code>categories</code>用法一致，它被用来标识文章中具有的知识领域，并用类似网络用语中的<code>关键字</code>来标记出来，构成另一个利于查找的维度。</p><h2 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h2><p>文章的布局，由于撰写文章，它的值有两种：<code>post</code>和<code>false</code>，当不想展示文章时，使用<code>false</code>标注</p><h2 id="banner-img"><a href="#banner-img" class="headerlink" title="banner_img"></a>banner_img</h2><p>当前文章页面顶部大图，可以使用本地图片的相对路径，也可以为外站链接。</p><pre><code class="hljs text">站内： banner_img: /img/site-fixed-images/example.jpg   # 对应存放在 /source/img/site-fixed-images/example.jpg站外： banner_img: https://static.zkqiang.cn/example.jpg</code></pre><p><strong>NOTE</strong>: 图片大小建议压缩到 1MB 以内，否则会严重拖慢页面加载</p><h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>显示在首页中和文章顶部的摘要信息，格式为：</p><pre><code class="hljs html">摘要<span class="hljs-comment">&lt;!-- more --&gt;</span>正文</code></pre><p>也可以使用<code>Front-Matter</code>格式：</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">这是标题</span><span class="hljs-attr">excerpt:</span> <span class="hljs-string">这是摘要</span><span class="hljs-meta">---</span></code></pre><h2 id="隐藏文章"><a href="#隐藏文章" class="headerlink" title="隐藏文章"></a>隐藏文章</h2><p>可以在site中隐藏文章，但依旧可以使用URL访问，格式如下：</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">hide:</span> <span class="hljs-literal">true</span><span class="hljs-meta">---</span></code></pre><h2 id="文章首页缩略图"><a href="#文章首页缩略图" class="headerlink" title="文章首页缩略图"></a>文章首页缩略图</h2><p>使用<code>Front-Matter</code>形式配置，与<code>banner_img</code>配置类似，格式如下：</p><pre><code class="hljs yaml"><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span></code></pre><h2 id="文章图片引用"><a href="#文章图片引用" class="headerlink" title="文章图片引用"></a>文章图片引用</h2><p>引用本地和外网资源图片，格式如下：</p><pre><code class="hljs text">![](/img/example.jpg)![](https://static.zkqiang.cn/example.jpg)</code></pre><h2 id="便签扩展"><a href="#便签扩展" class="headerlink" title="便签扩展"></a>便签扩展</h2><p>可以使用渲染引擎完成便签扩展，基本格式如下：</p><pre><code class="hljs text">&#123;% note success %&#125;文字 或者 `markdown` 均可&#123;% endnote %&#125;</code></pre><p>颜色样式：<code>primary</code>， <code>secondary</code>， <code>success</code>， <code>danger</code>， <code>warning</code>， <code>info</code>， <code>light</code>。</p><h2 id="组图"><a href="#组图" class="headerlink" title="组图"></a>组图</h2><p>如果想把多张图片按一定布局组合显示，你可以在 markdown 中按如下格式</p><pre><code class="hljs text">&#123;% gi total n1-n2-... %&#125;  ![](url)  ![](url)  ![](url)  ![](url)  ![](url)&#123;% endgi %&#125;</code></pre><p>total：图片总数量，对应中间包含的图片 url 数量<br>n1-n2-…：每行的图片数量，可以省略，默认单行最多 3 张图，求和必须相等于 total，否则按默认样式</p><p>例如 <code>&amp;#123;% gi 5 3-2 %&amp;#125;</code> ，代表共 5 张图，第一行 3 张图，第二行 2 张图。</p><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>添加脚注的正确方法如下：</p><pre><code class="hljs python">这是一句话[^<span class="hljs-number">1</span>][^<span class="hljs-number">1</span>]: 这是对应的脚注</code></pre><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码段请以<span style='color:red'>```</span>符号括起来，并在开头标注代码所属语言，可以根据喜好添加缩进，如：</p><pre><code class="hljs python"><span class="hljs-comment"># 类似这样</span>```python    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>:</span>        <span class="hljs-keyword">pass</span>```</code></pre><h2 id="其他扩展内容"><a href="#其他扩展内容" class="headerlink" title="其他扩展内容"></a>其他扩展内容</h2><p><code>hexo fluid</code>主题有很多扩展的选项，请参考<a href="https://hexo.fluid-dev.com/docs/guide/#%E6%96%87%E7%AB%A0%E9%A1%B5">这里</a></p>]]></content>
    
    
    <categories>
      
      <category>文章书写规范</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文章</tag>
      
      <tag>格式</tag>
      
      <tag>书写规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
