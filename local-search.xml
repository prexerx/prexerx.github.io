<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>你想通过本地构建CA来颁发证书么？</title>
    <link href="/2020/10/30/ca-certificate-authentication-md/"/>
    <url>/2020/10/30/ca-certificate-authentication-md/</url>
    
    <content type="html"><![CDATA[<div class="note note-light">            <p>进来看看我们如何在本地构建CA并颁发证书吧！</p>          </div><a id="more"></a><p>放在前头，本文并不是深入讲解CA鉴权的博文，而是就具体的使用整理的一篇精简短文。</p><p>没错，写这篇文章的时候确实是战战兢兢，生怕露出马脚，毕竟笔者不是从事安全专业的。</p><p>好在本文的所有内容均有实践验证，这让笔者在操刀的时候踏实不少。</p><p>书归正传，看看如何使用自建CA完成证书的签署和颁发吧。</p><h2 id="可复现的系统环境"><a href="#可复现的系统环境" class="headerlink" title="可复现的系统环境"></a>可复现的系统环境</h2><p>操作系统套件版本信息：</p><pre><code class="hljs text">prexer $ cat /proc/versionLinux version 4.18.0-25-generic (buildd@lcy01-amd64-025) (gcc version 8.3.0 (Ubuntu 8.3.0-6ubuntu1~18.10.1)) #26-Ubuntu SMP Mon Jun 24 09:32:08 UTC 2019</code></pre><p>openssl工具版本信息：</p><pre><code class="hljs text">prexer $ openssl versionOpenSSL 1.1.1  11 Sep 2018</code></pre><p>python3版本信息：</p><pre><code class="hljs text">prexer $ python3 --versionPython 3.8.5</code></pre><p>docker版本信息：</p><pre><code class="hljs text">prexer $ docker --versionDocker version 18.09.7, build 2d0083d</code></pre><p>这里只是笔者的环境，并不是说你必须一样才能通过，只不过在这个版本上，笔者是经过充分验证的。</p><h2 id="CA证书涉及的对象有哪些？"><a href="#CA证书涉及的对象有哪些？" class="headerlink" title="CA证书涉及的对象有哪些？"></a>CA证书涉及的对象有哪些？</h2><p>一一列举：</p><ul><li>假冒的授权中心，其实就是一个私钥/公钥对<ul><li>ca-key.pem &lt; 私钥</li><li>ca.pem &lt; 公钥</li></ul></li><li>服务端证书私钥/公钥对，这些还不够，如果要颁发证书，必须要有签名请求文件才可以<ul><li>server-key.pem &lt; 私钥</li><li>server.csr</li><li>ca.srl &lt; 服务端与客户端通用的</li><li>server-cert.pem &lt; 公钥</li></ul></li><li>类似的，客户端证书也是同样的一对密钥，请求文件当然不能少，只不过细微的部分和客户端配置不同，详见下文<ul><li>client-key.pem &lt; 私钥</li><li>client.csr</li><li>ca.srl</li><li>extfile.conf &lt; 扩展了SSL属性的文件</li><li>client-cert.pem &lt; 公钥</li></ul></li></ul><p>后续生成文件树的概览：</p><pre><code class="hljs shell">prexer $ tree CA/ CA_demo/CA/├── ca-key.pem├── ca.pem├── ca.srl├── client-cert.pem├── client.csr├── client-key.pem├── client.p12├── extfile.conf├── server-cert.pem├── server.csr└── server-key.pemCA_demo/├── https-home│   └── index.html└── nginx-conf    └── default.conf2 directories, 13 files</code></pre><h2 id="建立一个证书授权中心玩玩"><a href="#建立一个证书授权中心玩玩" class="headerlink" title="建立一个证书授权中心玩玩"></a>建立一个证书授权中心玩玩</h2><p>证书授权中心当然不能随便建立，这里说的建立是一个抽象层面的说法，本质上我们使用openssl工具建立一个本地的虚假证书机构。</p><p>虽然它颁发的不是官方的授权证书，但对于实际的应用来说依旧有用。</p><p>后文证书的私钥/公钥均采用<code>2048字节</code>，如果有需要可以提升。</p><p>简单一句完成建立：</p><pre><code class="hljs text">prexer $ sudo openssl genrsa -des3 -out ca-key.pemGenerating RSA private key, 2048 bit long modulus (2 primes)...................................................................+++++......................+++++e is 65537 (0x010001)Enter pass phrase for ca-key.pem:Verifying - Enter pass phrase for ca-key.pem:</code></pre><p>这里的<code>ca-key.pem</code>就是你本地CA授权机构的密钥，你就当他是授权机构。<br>执行的时候需要你输入密码，这个密码要记住，不仅后续的指令还要依赖它，没准以后其他情况也要用到哦。</p><h2 id="颁发认证机构的证书"><a href="#颁发认证机构的证书" class="headerlink" title="颁发认证机构的证书"></a>颁发认证机构的证书</h2><p>使用前文创建的证书机构密钥来建立一个代表机构的证书，当然也很简单：</p><pre><code class="hljs text">prexer $ sudo openssl req -new -x509 -days 365 -key ca-key.pem -out ca.pemEnter pass phrase for ca-key.pem:Can&#x27;t load /home/wei/.rnd into RNG140197562365120:error:2406F079:random number generator:RAND_load_file:Cannot open file:../crypto/rand/randfile.c:88:Filename=/home/wei/.rndYou are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &#x27;.&#x27;, the field will be left blank.-----Country Name (2 letter code) [AU]:State or Province Name (full name) [Some-State]:Locality Name (eg, city) []:Organization Name (eg, company) [Internet Widgits Pty Ltd]:Organizational Unit Name (eg, section) []:Common Name (e.g. server FQDN or YOUR name) []:prexer.gitee.ioEmail Address []:</code></pre><p>相关参数请自行到搜索引擎查询，讲解的文章成片飘落…<br>这里还要说明两点：</p><ol><li>在输入FQDN，也就是Common Name的时候给一个服务的名字，正式的时候需要添加详细的信息，这里是一个演示，所以只是例子。</li><li>指令执行的时候需要输入ca-key.pem的密码，你懂的。</li></ol><h2 id="创建用于服务端的证书签名请求和密钥"><a href="#创建用于服务端的证书签名请求和密钥" class="headerlink" title="创建用于服务端的证书签名请求和密钥"></a>创建用于服务端的证书签名请求和密钥</h2><p>在正式颁发指定服务端证书的时候，需要一个证书签名请求，而这个证书的签名请求还需要你为服务器生成一个服务端的密钥文件。</p><p>那么，我们先生成一个服务端的密钥文件：</p><pre><code class="hljs text">prexer $ sudo openssl genrsa -des3 -out server-key.pemGenerating RSA private key, 2048 bit long modulus (2 primes).........+++++.............................................+++++e is 65537 (0x010001)Enter pass phrase for server-key.pem:Verifying - Enter pass phrase for server-key.pem:</code></pre><p>没错，他和生成虚假认证机构的密钥是相似的，过程中需要你为它也设置一个密码，这个密码后续我们会删除，毕竟大部分应用场景都不需要密码完成认证。</p><p>接下来，用上面的服务器密钥来生成一个证书签名请求：</p><pre><code class="hljs text">prexer $ sudo openssl req -new -key server-key.pem -out server.csrEnter pass phrase for server-key.pem:Can&#x27;t load /home/wei/.rnd into RNG139737719624896:error:2406F079:random number generator:RAND_load_file:Cannot open file:../crypto/rand/randfile.c:88:Filename=/home/wei/.rndYou are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &#x27;.&#x27;, the field will be left blank.-----Country Name (2 letter code) [AU]:State or Province Name (full name) [Some-State]:Locality Name (eg, city) []:Organization Name (eg, company) [Internet Widgits Pty Ltd]:Organizational Unit Name (eg, section) []:Common Name (e.g. server FQDN or YOUR name) []:*Email Address []:Please enter the following &#x27;extra&#x27; attributesto be sent with your certificate requestA challenge password []:An optional company name []:</code></pre><p>这里除了要输入密码，还要重点注意<code>FQDN</code>这个选项，这里设置为<code>*</code>是表示允许该证书在任意的一台服务器上都可以使用，当然，你也可以按照你的需求指定一个有效的服务器，如：prexer.example.org</p><h2 id="正式生成服务端的证书"><a href="#正式生成服务端的证书" class="headerlink" title="正式生成服务端的证书"></a>正式生成服务端的证书</h2><p>有了请求，向认证机构申请证书还是比较简单的，不过在请求前，要先生成一个<code>srl</code>文件：</p><pre><code class="hljs text">prexer $ echo 01 &gt; $PWD/ca.srl</code></pre><p>开始颁发证书吧：</p><pre><code class="hljs text">prexer $ sudo openssl x509 -req -days 365 -in server.csr -CA ca.pem -CAkey ca-key.pem -out server-cert.pemSignature oksubject=C = AU, ST = Some-State, O = Internet Widgits Pty Ltd, CN = *Getting CA Private KeyEnter pass phrase for ca-key.pem:</code></pre><p>密码什么的相信你已经熟练的使用了，接下来完成一个实用的步骤，移除服务端的密钥密码：</p><pre><code class="hljs text">prexer $ sudo openssl rsa -in server-key.pem -out server-key.pemEnter pass phrase for server-key.pem:writing RSA key</code></pre><p>如果你还是没安全感，那就让文件的权限跟窄一些：</p><pre><code class="hljs text">sudo chmod 0600 *.pem</code></pre><p>这一步骤你可以根据需求执行，到现在我们拥有的文件试图应该是:</p><pre><code class="hljs text">prexer $ ls -ltotal 24-rw------- 1 root root 1743 10月 30 23:06 ca-key.pem-rw------- 1 root root 1318 10月 30 23:12 ca.pem-rw-r--r-- 1 wei  wei     3 10月 30 23:32 ca.srl-rw------- 1 root root 1151 10月 30 23:32 server-cert.pem-rw-r--r-- 1 root root  972 10月 30 23:24 server.csr-rw------- 1 root root 1675 10月 30 23:36 server-key.pem</code></pre><h2 id="创建客户端的密钥和证书"><a href="#创建客户端的密钥和证书" class="headerlink" title="创建客户端的密钥和证书"></a>创建客户端的密钥和证书</h2><p>操作方法和服务器端相似，先生成客户端密钥：</p><pre><code class="hljs text">prexer $ sudo openssl genrsa -des3 -out client-key.pemGenerating RSA private key, 2048 bit long modulus (2 primes).............+++++...................................+++++e is 65537 (0x010001)Enter pass phrase for client-key.pem:Verifying - Enter pass phrase for client-key.pem:</code></pre><p>这个阶段同样要设置一个临时的密码，后续会删除。</p><p>接下来创建一个客户端证书签名请求，和前文一样，是一个CSR文件：</p><pre><code class="hljs text">prexer $ sudo openssl req -new -key client-key.pem -out client.csrEnter pass phrase for client-key.pem:Can&#x27;t load /home/wei/.rnd into RNG140471898436800:error:2406F079:random number generator:RAND_load_file:Cannot open file:../crypto/rand/randfile.c:88:Filename=/home/wei/.rndYou are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &#x27;.&#x27;, the field will be left blank.-----Country Name (2 letter code) [AU]:State or Province Name (full name) [Some-State]:Locality Name (eg, city) []:Organization Name (eg, company) [Internet Widgits Pty Ltd]:Organizational Unit Name (eg, section) []:Common Name (e.g. server FQDN or YOUR name) []:Email Address []:Please enter the following &#x27;extra&#x27; attributesto be sent with your certificate requestA challenge password []:An optional company name []:</code></pre><p>这里除了密码没有什么要注意的地方，也是客户端与服务端的第一点差别。</p><p>第二点差别是，有时候需要在使用客户端的时候添加SSL的扩展属性，也就类似TSL/SSL这样的需求。<br>其实也很好办，这里给出一个简单的样例，先生成一个SSL扩展文件：</p><pre><code class="hljs text">prexer $ echo extendedKeyUsage = clientAuth &gt; extfile.conf</code></pre><p>来吧，都准备好了，那就进行签名授书喽：</p><pre><code class="hljs text">prexer $ sudo openssl x509 -req -days 365 -in client.csr -CA ca.pem -CAkey ca-key.pem -out client-cert.pem -extfile extfile.confSignature oksubject=C = AU, ST = Some-State, O = Internet Widgits Pty LtdGetting CA Private KeyEnter pass phrase for ca-key.pem:</code></pre><p>输入认证机构密钥密码后，客户端的证书也就授权完成了，一鼓作气，让我们把客户端密钥的密码删掉吧：</p><pre><code class="hljs text">prexer $ sudo openssl rsa -in client-key.pem -out client-key.pemEnter pass phrase for client-key.pem:writing RSA key</code></pre><p>好了，到了这里所有的内容都已经准备齐全了，他们应该是这样的：</p><pre><code class="hljs text">prexer $ ls -ltotal 40-rw------- 1 root root 1743 10月 30 23:06 ca-key.pem-rw------- 1 root root 1318 10月 30 23:12 ca.pem-rw-r--r-- 1 wei  wei     3 10月 30 23:53 ca.srl-rw-r--r-- 1 root root 1176 10月 30 23:53 client-cert.pem-rw-r--r-- 1 root root  956 10月 30 23:46 client.csr-rw------- 1 root root 1679 10月 30 23:56 client-key.pem-rw-r--r-- 1 wei  wei    30 10月 30 23:51 extfile.conf-rw------- 1 root root 1151 10月 30 23:32 server-cert.pem-rw-r--r-- 1 root root  972 10月 30 23:24 server.csr-rw------- 1 root root 1675 10月 30 23:36 server-key.pem</code></pre><p>那么接下来的部分我们谈谈验证，毕竟你有了这些东东还要用不是？</p><h2 id="如何验证授权的证书？"><a href="#如何验证授权的证书？" class="headerlink" title="如何验证授权的证书？"></a>如何验证授权的证书？</h2><p>现在，我们已经有了服务端和客户端的双向证书，那么就用下面的案例来验证：</p><ul><li>使用Nginx搭建一个反向代理服务器，在配置文件中使用TSL认证，使用授权的服务端证书，当然这部分要以来https/http协议来完成</li><li>在访问服务器的客户端，不安装授权的客户端证书来问指定服务器</li><li>在访问服务器的客户端，安装授权的客户端证书，然后访问指定服务器</li></ul><h3 id="搭建一个最简单的http服务器"><a href="#搭建一个最简单的http服务器" class="headerlink" title="搭建一个最简单的http服务器"></a>搭建一个最简单的http服务器</h3><p>利用python的内置模块搭建http服务器是一件很简单的事情，不过它是一个简易的http服务器，用来做验证和开发。</p><p>我们创建一个目录，用来存放http服务的主页内容：</p><pre><code class="hljs shell">prexer $ mkdir -p $PWD/CA_demo/http-home</code></pre><p>然后写一个简单的索引文件：</p><pre><code class="hljs shell">prexer $ cat &gt; $PWD/CA_demo/http-home/index.html &lt;&lt;EOF&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h3&gt;Python SimpleHTTPServer&lt;/h3&gt;    &lt;p style=&quot;margin-left: 30px; color: rebeccapurple&quot;&gt;Python 3 Web Server&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;EOF</code></pre><p>最后只要到<code>http-home</code>目录启动python内置的http服务即可：</p><pre><code class="hljs shell">prexer $ (cd $PWD/CA_demo/http-home/ &amp;&amp; python3 -m http.server 8008 &amp;)</code></pre><p>这里我们绑定了8008端口，后续在配置nginx会重定向到它，看到这里的括号了么，没错它是防止你的操作对<code>父SHELL</code>产生影响而已。</p><p>为了模拟一个有用的设计，我们将本机的地址映射为想要的主机名，后续都用<code>prexer.home</code>来完成<code>localhost</code>或<code>127.0.0.1</code>的映射。<br>其实还可以搭建一个DNS服务来完成这件事，其实也很简单，本站已有相关的文章讲解DNS服务其的内网搭建，请使用本站搜索引擎来翻阅吧。</p><p>完成映射：</p><pre><code class="hljs shell">prexer $ sudo echo 127.0.0.1 prexer.home &gt;&gt; /etc/hosts</code></pre><p>现在你访问<code>http://prexer.home:8008</code>的界面应该是这样的(请保证你的8008端口没有被占用)：<br><img src="/img/blog-images/ca_http_index_show.png" alt="理想的显示结果"></p><h3 id="构建一个Ngix反向代理服务"><a href="#构建一个Ngix反向代理服务" class="headerlink" title="构建一个Ngix反向代理服务"></a>构建一个Ngix反向代理服务</h3><p>使用docker构建一Nginx服务简直太简单了，如何安装docker请参考本站的其他文章，依旧直接使用本站的搜索引擎即可。</p><p>接下来默认你已经拥有了docker环境，来一起搭建一个Nginx。</p><p>不过在搭建之前还有一些要准备的工作，其实也很容易，就是一个nginx的配置文件:</p><pre><code class="hljs shell">prexer $ mkdir -p $PWD/CA_demo/nginx-confprexer $ cat &gt; $PWD/CA_demo/nginx-conf/default.conf &lt;&lt;EOFserver &#123;    listen      8000;    server_name prexer.home;    listen   443 ssl;    ssl_certificate             /etc/nginx/CA/server-cert.pem;    ssl_certificate_key         /etc/nginx/CA/server-key.pem;    ssl_client_certificate      /etc/nginx/CA/ca.pem;    ssl_verify_client           on;    ssl_session_cache           shared:SSL:1m;    ssl_session_timeout         5m;    ssl_protocols               SSLv2 SSLv3 TLSv1.2;    ssl_ciphers                 HIGH:!aNULL:!MD5;    ssl_prefer_server_ciphers   on;    location / &#123;        proxy_pass http://localhost:8008/;    &#125;&#125;EOF</code></pre><p>好了，开始构建nginx服务容器：</p><pre><code class="hljs shell">prexer $ docker run -t --name ca_nginx -d \--net=host \--volume `pwd`/CA:/etc/nginx/CA \--volume `pwd`/CA_demo/nginx-conf/default.conf:/etc/nginx/conf.d/default.conf \--privileged=true \nginx:latest</code></pre><p>到了这里你的目录结构应该是这样才对：</p><pre><code class="hljs shell">prexer $ tree CA_demo/ CA/CA_demo/├── https-home│   └── index.html└── nginx-conf    └── default.confCA/├── ca-key.pem├── ca.pem├── ca.srl├── client-cert.pem├── client.csr├── client-key.pem├── extfile.conf├── server-cert.pem├── server.csr└── server-key.pem2 directories, 12 files</code></pre><p>查看docker容器的输出可以这样：<code>docker logs -f ca_nginx</code></p><p>到这里nginx也搭建完成了，下面来验证。</p><h3 id="通过浏览器来验证自建证书的有效性"><a href="#通过浏览器来验证自建证书的有效性" class="headerlink" title="通过浏览器来验证自建证书的有效性"></a>通过浏览器来验证自建证书的有效性</h3><p>首先，浏览器没有安装证书的时候，应该得到这样的结果：<br><img src="/img/blog-images/ca_no_cert.png" alt="没有证书的时候"></p><p>很遗憾，浏览器并不能直接使用刚才我们制定的证书格式，它需要用一个转换后的格式，这里我们生成<code>.p12</code>文件，至于格式的知识请自行索引。</p><pre><code class="hljs shell">prexer $ sudo openssl pkcs12 -export -in client-cert.pem -inkey client-key.pem -out client.p12 -name &quot;iot&quot;</code></pre><p>这里转换成另一种格式的证书时，需要输入密码，请记住它，后续要在浏览器中使用！</p><p>好了现在我们有了<code>client.p12</code>文件，浏览器可以很好的支持它，你肯定已经记住了它的生成位置，现在通过浏览器添加证书：<br><img src="/img/blog-images/ca_import_cert_to_firefox.png" alt="导入证书步骤"></p><p>添加完成后再次访问<code>https://prexer.home</code>，应该是这样：<br><img src="/img/blog-images/ca_cert_imported.png" alt="添加证书后"></p><p>到了这里所有相关证书的生成和验证流程就讲解完成了，真心希望对你有帮助呢 ^_^</p>]]></content>
    
    
    <categories>
      
      <category>CA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CA</tag>
      
      <tag>证书</tag>
      
      <tag>鉴权</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在内网快速利用docker搭建DNS服务器</title>
    <link href="/2020/10/29/docker/internal_dns_server_setup/"/>
    <url>/2020/10/29/docker/internal_dns_server_setup/</url>
    
    <content type="html"><![CDATA[<div class="note note-light">            <p>如果你还犯愁，如何在内网搭建DNS服务器，那么请看看这里吧。</p>          </div><a id="more"></a><h2 id="当前主机是否已经启用53端口？"><a href="#当前主机是否已经启用53端口？" class="headerlink" title="当前主机是否已经启用53端口？"></a>当前主机是否已经启用53端口？</h2><p>如果你不清楚53端口的功能，请查看下<code>/etc/services</code>文件，它会告诉你答案。</p><p>为了顺利进行下一步，需要确保你的机器上没有开启53端口，也就是说你的主机不是一个DNS Server。</p><p>如何确定呢？当然要使用<code>netstat命令</code>来查看端口，当然配合<code>lsof命令</code>也许会更明确。</p><p>比如笔者本机就是这样的：</p><pre><code class="hljs shell">prexer $ netstat -ntulp | grep 53(Not all processes could be identified, non-owned process info will not be shown, you would have to be root to see it all.)tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      -udp        0      0 127.0.0.53:53           0.0.0.0:*                           -udp        0      0 0.0.0.0:5353            0.0.0.0:*                           -udp6       0      0 :::5353                 :::*                                -prexer $ sudo lsof -i:53COMMAND   PID            USER   FD   TYPE DEVICE SIZE/OFF NODE NAMEsystemd-r 778 systemd-resolve   12u  IPv4  20918      0t0  UDP localhost:domainsystemd-r 778 systemd-resolve   13u  IPv4  20919      0t0  TCP localhost:domain (LISTEN)</code></pre><p>如果找到了端口占用，只要关闭指定的程序即可，简单来说就是这样：</p><pre><code class="hljs livecodeserver">prexer $ sudo systemctl <span class="hljs-built_in">stop</span> systemd-<span class="hljs-built_in">resolve</span><span class="hljs-comment"># 或者</span>prexer $ sudo <span class="hljs-built_in">kill</span> your_pid</code></pre><h2 id="用什么来构建DNS服务器呢？"><a href="#用什么来构建DNS服务器呢？" class="headerlink" title="用什么来构建DNS服务器呢？"></a>用什么来构建DNS服务器呢？</h2><p>当然是大名鼎鼎的<code>DNSmasq</code>了，如果你不了解，您这边请: <a href="http://www.thekelleys.org.uk/dnsmasq/doc.html%E3%80%82">http://www.thekelleys.org.uk/dnsmasq/doc.html。</a></p><p>这个项目是有命令行支持的，参考官网也可以很容易构建出来，不过本文打算使用更见到的docker容器来完成这件事。</p><p>说到这里，请注意，本文并没有直接使用官方提供的docker镜像，而是使用了另一个拥有web支持的docker镜像。</p><ul><li><p>官方镜像在<a href="https://hub.docker.com/r/andyshinn/dnsmasq/">这里</a></p></li><li><p>有web支持的镜像在<a href="https://github.com/jpillora/docker-dnsmasq">这里</a></p></li></ul><h2 id="构建一个符合你胃口的DNSmasq的配置文件"><a href="#构建一个符合你胃口的DNSmasq的配置文件" class="headerlink" title="构建一个符合你胃口的DNSmasq的配置文件"></a>构建一个符合你胃口的DNSmasq的配置文件</h2><p>对于配置docker镜像而言，配置文件肯定是逃不了的，你可以先看看<a href="http://oss.segetech.com/intra/srv/dnsmasq.conf">官方的配置文档</a>，了解有什么后，再动手也不迟。</p><p>这里我们介绍一个通用且简单的配置，当你学完后可以自己进行修改，多开心。</p><p>配置文件及解释如下：(将这个文件保存为：dnsmasq.conf文件，存储在你当前的工作目录或者任意可指定的目录即可)</p><pre><code class="hljs routeros"><span class="hljs-comment"># filename: dnsmasq.conf</span><span class="hljs-comment"># 需要存储log，后续再命令行中指定log的限制大小</span>log-queries<span class="hljs-comment"># 指定一个自定义的解析文件，它可以保证你不用修改原始的配置文件/etc/resolv.conf</span><span class="hljs-attribute">resolv-file</span>=/tmp/resolv.conf<span class="hljs-comment"># 一个测试的名字，IP地址是内部网络的另一台主机，通过这个名字来完成后续的验证</span><span class="hljs-attribute">address</span>=/hello.remote/10.22.52.229<span class="hljs-comment"># upstream nameserver，也就是找不到靠上游的道理</span><span class="hljs-comment"># server=/localnet/127.0.0.1 # 不加也可以，添加非公开的内网DNS，就像联机打游戏一样 </span><span class="hljs-attribute">server</span>=10.22.0.1<span class="hljs-attribute">server</span>=10.22.0.2</code></pre><p>复制一份解析文件：</p><pre><code class="hljs shell">prexer $ sudo cp /etc/resolv.conf /tmp/resolv.conf</code></pre><p>到了这里，基本的配置就算完成了，很简单吧，之后我们开始启动DNSmasq容器。</p><h2 id="开始构建激动人心的docker容器"><a href="#开始构建激动人心的docker容器" class="headerlink" title="开始构建激动人心的docker容器"></a>开始构建激动人心的docker容器</h2><p>众所周知，容器的使用廉价的可怜，所以你几乎不用知道细节就可以搭建一个完美的沙盒环境（一点不知道也不行哈…)。按照官方文档的指示，你当然可以修改docker启动的参数，然后鼓捣鼓捣自己的配置，反正玩不坏，尽情尝试。不过为了教学，请看看我的例子：</p><pre><code class="hljs shell">docker run -d\    --name dnsmasq \    --rm \    -p 53:53/udp \    -p 53:53/tcp \    -p 8080:8080 \    -v `pwd`/dnsmasq.conf:/etc/dnsmasq.conf \    --log-opt &quot;max-size=100m&quot; \    -e &quot;HTTP_USER=root&quot; \    -e &quot;HTTP_PASS=root&quot; \    jpillora/dnsmasq</code></pre><p>一些简单的参数解释：</p><pre><code class="hljs livescript">docker run -d<span class="hljs-string">\</span> <span class="hljs-comment"># 以守护进程的方式运行容器</span>    --name dnsmasq <span class="hljs-string">\</span> <span class="hljs-comment"># 容器的名字</span>    --rm <span class="hljs-string">\</span> <span class="hljs-comment"># 用完后删除，即你stop的时候就会删除哦</span>    -p <span class="hljs-number">53</span>:<span class="hljs-number">53</span>/udp <span class="hljs-string">\</span> <span class="hljs-comment"># 暴露容器的53端口和宿主机关联，udp/tcp协议如果你不懂，简单百科一下</span>    -p <span class="hljs-number">53</span>:<span class="hljs-number">53</span>/tcp <span class="hljs-string">\</span>    -p <span class="hljs-number">8080</span>:<span class="hljs-number">8080</span> <span class="hljs-string">\</span> <span class="hljs-comment"># 暴露容器的web端口，便于后续再网页上查看和配置</span>    -v `pwd`/dnsmasq.conf:/etc/dnsmasq.conf <span class="hljs-string">\</span> <span class="hljs-comment"># 重点，配置文件的关联，这个逻辑卷的知识你可以自行科普</span>    --log-opt <span class="hljs-string">&quot;max-size=100m&quot;</span> <span class="hljs-string">\</span> <span class="hljs-comment"># 限制输出的log文件的大小，很简单是吧，呼应前文</span>    -e <span class="hljs-string">&quot;HTTP_USER=root&quot;</span> <span class="hljs-string">\</span> <span class="hljs-comment"># 登录web的用户名和密码</span>    -e <span class="hljs-string">&quot;HTTP_PASS=root&quot;</span> <span class="hljs-string">\</span>    jpillora/dnsmasq <span class="hljs-comment"># 包含web的基础dnsmasq镜像</span></code></pre><p>查看启动状态，只是一些基础的docker指令：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> &gt; docker ps -a |grep dnsmasq <span class="hljs-comment"># 看容器的启动状态</span></span>prexer $ docker ps -a|grep dnsmasq6d75bfc34244        jpillora/dnsmasq                       &quot;webproc --config /e…&quot;   18 seconds ago      Up 17 seconds       0.0.0.0:53-&gt;53/tcp, 0.0.0.0:8080-&gt;8080/tcp, 0.0.0.0:53-&gt;53/udp   dnsmasq<span class="hljs-meta">#</span><span class="bash"> &gt; docker logs -f dnsmasq <span class="hljs-comment"># 看容器的标准输出log</span></span>prexer $ docker logs -f dnsmasq[webproc] 2020/10/30 00:37:30 loaded config files changes from disk[webproc] 2020/10/30 00:37:30 agent listening on http://0.0.0.0:8080...dnsmasq: started, version 2.80 cachesize 150dnsmasq: compile time options: IPv6 GNU-getopt no-DBus no-i18n no-IDN DHCP DHCPv6 no-Lua TFTP no-conntrack ipset auth no-DNSSEC loop-detect inotify dumpfilednsmasq: using nameserver 10.22.0.2#53dnsmasq: using nameserver 10.22.0.1#53dnsmasq: read /etc/hosts - 7 addresses</code></pre><p>至于是否启动成功，看看输出结果，对比对比就成了。</p><h2 id="来吧，一起可视化查看与验证"><a href="#来吧，一起可视化查看与验证" class="headerlink" title="来吧，一起可视化查看与验证"></a>来吧，一起可视化查看与验证</h2><p>从浏览器登录你已经配置的主机，方法如下：</p><pre><code class="hljs awk">在浏览器中输入：http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8080</span> 或者 http:<span class="hljs-regexp">//</span>remote_ip_address:<span class="hljs-number">8080</span></code></pre><p>这样就能到达登录界面，用户名和密码是之前命令行参数中配置的，请自行填写，效果如下：</p><p><img src="/img/blog-images/dns_web_show.png" alt="login web"></p><p>登录后的界面如下：</p><p><img src="/img/blog-images/dns_web_display.png" alt="display web"></p><p>在验证之前还需要一点知识要梳理：</p><p>首先，之前复制的DNS解析文件<code>/tmp/resolv.conf</code>是配置的DNSmasq解析的上游服务文件，具体请看下面的解释：</p><pre><code class="hljs vala"><span class="hljs-meta"># Change this line if you want dns to get its upstream servers from</span><span class="hljs-meta"># somewhere other that /etc/resolv.conf</span><span class="hljs-meta">#resolv-file=</span></code></pre><p>很多同学在里面配置了<code>nameserver 127.0.0.1</code>本地的地址，想要使用本地的docker DNS服务，其实还不行，需要你真正配置本机的DNS解析文件才可以，也就是修改<code>/etc/resolv.conf</code>添加如下信息：</p><pre><code class="hljs angelscript">nameserver <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span></code></pre><p>到这里基本上可以进行下一步了。</p><p>那么我们验证一下配置的结果吧：</p><p>首先用你们最熟悉的<code>ping</code>指令，走个ICMP协议看看：</p><pre><code class="hljs routeros">prexer $<span class="hljs-built_in"> ping </span>hello.remote -c 3PING hello.remote (10.22.52.229) 56(84) bytes of data.64 bytes <span class="hljs-keyword">from</span> CNSHZ-ED-SVR097.sierrawireless.local (10.22.52.229): <span class="hljs-attribute">icmp_seq</span>=1 <span class="hljs-attribute">ttl</span>=64 <span class="hljs-attribute">time</span>=0.190 ms64 bytes <span class="hljs-keyword">from</span> CNSHZ-ED-SVR097.sierrawireless.local (10.22.52.229): <span class="hljs-attribute">icmp_seq</span>=2 <span class="hljs-attribute">ttl</span>=64 <span class="hljs-attribute">time</span>=0.257 ms64 bytes <span class="hljs-keyword">from</span> CNSHZ-ED-SVR097.sierrawireless.local (10.22.52.229): <span class="hljs-attribute">icmp_seq</span>=3 <span class="hljs-attribute">ttl</span>=64 <span class="hljs-attribute">time</span>=0.230 ms--- hello.remote<span class="hljs-built_in"> ping </span>statistics ---3 packets transmitted, 3 received, 0% packet loss, time 1998msrtt min/avg/max/mdev = 0.190/0.225/0.257/0.032 ms</code></pre><p>在来看看主机的IP地址映射关系，当然要用<code>host</code>指令：</p><pre><code class="hljs routeros">prexer $ host hello.remotehello.remote has<span class="hljs-built_in"> address </span>10.22.52.229</code></pre><p>其他的协议不用一一验证了，应为这是标准的端口，也是通用的tcp/udp协议簇，如果你还好奇，可以验证<code>ssh</code>或者<code>dig</code>之类的指令玩玩。</p><h2 id="内网其他主机如何使用你的DNS服务器？"><a href="#内网其他主机如何使用你的DNS服务器？" class="headerlink" title="内网其他主机如何使用你的DNS服务器？"></a>内网其他主机如何使用你的DNS服务器？</h2><p>本机用当然还不够，要内网其他同事能够使用才行，其实用起来依旧很简单，就是在内网的任意机器上（可达你的主机），修改<code>/etc/resolv.conf</code>文件，添加一行：</p><pre><code class="hljs xml">nameserver <span class="hljs-tag">&lt;<span class="hljs-name">your_dns_server_ip_address</span>&gt;</span></code></pre><p><code>&lt;your_dns_server_ip_address&gt;</code>这个替换你的主机IP就可以了。</p><p>赶快用起来！^_^</p>]]></content>
    
    
    <categories>
      
      <category>docker/hello</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>dns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>推荐一个加速git仓库下载的方法</title>
    <link href="/2020/10/24/base/git_speed_up_downloading/"/>
    <url>/2020/10/24/base/git_speed_up_downloading/</url>
    
    <content type="html"><![CDATA[<div class="note note-light">            <p>如果访问github限速，那就试试这个方法吧!</p>          </div><a id="more"></a><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>今时已不同往日，网络资源已经逐渐被管控和限制，就当下的形式而言，外网访问的制约，对于一个程序员来说谈不上好事还是坏事。</p><p>不过，如果你在墙内看不到外面的风景，那确实有点可惜，不管是因为墙太高（就像进击的巨人一样）还是其他原因。</p><p>换个法子，将墙外你感兴趣的风景，借助公家条件，移植到墙内来，这样就可以满足你的欲望。</p><p>一样的，github对于国内用户来说已经限速，下载个几十兆的仓库都要好几十分钟，并且有断开的风险，所以请借助gitee达到你的目的吧。</p><h2 id="如何做？"><a href="#如何做？" class="headerlink" title="如何做？"></a>如何做？</h2><p>很简单，利用码云gitee的同步功能，来同步你在github上感兴趣的仓库，然后利用国内极速的网络来完成clone或者下载。</p><h3 id="定位github上的仓库目标"><a href="#定位github上的仓库目标" class="headerlink" title="定位github上的仓库目标"></a>定位github上的仓库目标</h3><p>比如，你在github上看到中了：<a href="https://github.com/hexojs/hexo-starter">https://github.com/hexojs/hexo-starter</a></p><p>那么，请复制这个URL。</p><h3 id="注册并创建gitee仓库"><a href="#注册并创建gitee仓库" class="headerlink" title="注册并创建gitee仓库"></a>注册并创建gitee仓库</h3><p>登录gitee官网：<a href="https://gitee.com/">https://gitee.com/</a></p><p>注册流程交给你自己，就像其他网站注册一样，比较好玩的是国内的gitee可使用手机号绑定并登陆。</p><p>找到并点击<code>新建仓库</code>，然后拖到最后，点击<code>导入仓库</code>，并填写刚才复制的URL地址。</p><p>gitee会自动帮你填充仓库的信息，当然你也可自己修改感兴趣的部分。</p><p>最后点击<code>创建</code>，好了，完成。</p><h3 id="使用gitee"><a href="#使用gitee" class="headerlink" title="使用gitee"></a>使用gitee</h3><p>gitee的用法和github一样，并不特殊，你只需要换一个URL地址。</p><p>从以前的：<br><code>git clone https://github.com/hexojs/hexo-starter.git</code></p><p>到现在的：<br><code>git clone https://gitee.com/prexer/hexo-starter.git</code></p><p>享受极速服务的感觉很不错吧？^_^</p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>gitee</tag>
      
      <tag>github</tag>
      
      <tag>git加速</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文章编写规范</title>
    <link href="/2020/02/20/articles_writing_rules/"/>
    <url>/2020/02/20/articles_writing_rules/</url>
    
    <content type="html"><![CDATA[<div class="note note-light">            <p>本站文章书写规范参考指南。</p>          </div><a id="more"></a><p>文章开头类似如下的语法：</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">xxx</span><span class="hljs-attr">date:</span>  <span class="hljs-string">xxx</span><span class="hljs-attr">categories:</span> <span class="hljs-string">xxx</span><span class="hljs-string">tags：</span> <span class="hljs-string">xxx</span><span class="hljs-attr">layout:</span> <span class="hljs-string">xxx</span><span class="hljs-meta">---</span></code></pre><p>在Hexo中叫做<code>Front-Matter</code>，通过它你可以限定文章的一些行为。</p><p>所以本文重点说明Hexo的<code>Front-Matter</code>和<code>文章书写格式</code></p><h1 id="Front-Matter中必要的信息"><a href="#Front-Matter中必要的信息" class="headerlink" title="Front-Matter中必要的信息"></a>Front-Matter中必要的信息</h1><h2 id="title"><a href="#title" class="headerlink" title="title"></a>title</h2><p>文章标题，内置中文支持</p><h2 id="date"><a href="#date" class="headerlink" title="date"></a>date</h2><p>文章撰写时间</p><h2 id="categories"><a href="#categories" class="headerlink" title="categories"></a>categories</h2><p>文章归档种类，一般认为，<code>categories</code>用来描述文章作者的知识结构树，文章应该明确属于某一个领域，哪怕它已经借鉴了其他领域的知识。</p><h2 id="tags"><a href="#tags" class="headerlink" title="tags"></a>tags</h2><p>文章的标签，一般认为，<code>tags</code>并不和<code>categories</code>用法一致，它被用来标识文章中具有的知识领域，并用类似网络用语中的<code>关键字</code>来标记出来，构成另一个利于查找的维度。</p><h2 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h2><p>文章的布局，由于撰写文章，它的值有两种：<code>post</code>和<code>false</code>，当不想展示文章时，使用<code>false</code>标注</p><h2 id="banner-img"><a href="#banner-img" class="headerlink" title="banner_img"></a>banner_img</h2><p>当前文章页面顶部大图，可以使用本地图片的相对路径，也可以为外站链接。</p><pre><code class="hljs text">站内： banner_img: /img/site-fixed-images/example.jpg   # 对应存放在 /source/img/site-fixed-images/example.jpg站外： banner_img: https://static.zkqiang.cn/example.jpg</code></pre><p><strong>NOTE</strong>: 图片大小建议压缩到 1MB 以内，否则会严重拖慢页面加载</p><h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>显示在首页中和文章顶部的摘要信息，格式为：</p><pre><code class="hljs html">摘要<span class="hljs-comment">&lt;!-- more --&gt;</span>正文</code></pre><p>也可以使用<code>Front-Matter</code>格式：</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">这是标题</span><span class="hljs-attr">excerpt:</span> <span class="hljs-string">这是摘要</span><span class="hljs-meta">---</span></code></pre><h2 id="隐藏文章"><a href="#隐藏文章" class="headerlink" title="隐藏文章"></a>隐藏文章</h2><p>可以在site中隐藏文章，但依旧可以使用URL访问，格式如下：</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">hide:</span> <span class="hljs-literal">true</span><span class="hljs-meta">---</span></code></pre><h2 id="文章首页缩略图"><a href="#文章首页缩略图" class="headerlink" title="文章首页缩略图"></a>文章首页缩略图</h2><p>使用<code>Front-Matter</code>形式配置，与<code>banner_img</code>配置类似，格式如下：</p><pre><code class="hljs yaml"><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span></code></pre><h2 id="文章图片引用"><a href="#文章图片引用" class="headerlink" title="文章图片引用"></a>文章图片引用</h2><p>引用本地和外网资源图片，格式如下：</p><pre><code class="hljs text">![](/img/example.jpg)![](https://static.zkqiang.cn/example.jpg)</code></pre><h2 id="便签扩展"><a href="#便签扩展" class="headerlink" title="便签扩展"></a>便签扩展</h2><p>可以使用渲染引擎完成便签扩展，基本格式如下：</p><pre><code class="hljs text">&#123;% note success %&#125;文字 或者 `markdown` 均可&#123;% endnote %&#125;</code></pre><p>颜色样式：<code>primary</code>， <code>secondary</code>， <code>success</code>， <code>danger</code>， <code>warning</code>， <code>info</code>， <code>light</code>。</p><h2 id="组图"><a href="#组图" class="headerlink" title="组图"></a>组图</h2><p>如果想把多张图片按一定布局组合显示，你可以在 markdown 中按如下格式</p><pre><code class="hljs text">&#123;% gi total n1-n2-... %&#125;  ![](url)  ![](url)  ![](url)  ![](url)  ![](url)&#123;% endgi %&#125;</code></pre><p>total：图片总数量，对应中间包含的图片 url 数量<br>n1-n2-…：每行的图片数量，可以省略，默认单行最多 3 张图，求和必须相等于 total，否则按默认样式</p><p>例如 <code>&amp;#123;% gi 5 3-2 %&amp;#125;</code> ，代表共 5 张图，第一行 3 张图，第二行 2 张图。</p><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>添加脚注的正确方法如下：</p><pre><code class="hljs python">这是一句话[^<span class="hljs-number">1</span>][^<span class="hljs-number">1</span>]: 这是对应的脚注</code></pre><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码段请以<span style='color:red'>```</span>符号括起来，并在开头标注代码所属语言，可以根据喜好添加缩进，如：</p><pre><code class="hljs python"><span class="hljs-comment"># 类似这样</span>​```python    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>:</span>        <span class="hljs-keyword">pass</span>```</code></pre><h2 id="其他扩展内容"><a href="#其他扩展内容" class="headerlink" title="其他扩展内容"></a>其他扩展内容</h2><p><code>hexo fluid</code>主题有很多扩展的选项，请参考<a href="https://hexo.fluid-dev.com/docs/guide/#%E6%96%87%E7%AB%A0%E9%A1%B5">这里</a></p>]]></content>
    
    
    <categories>
      
      <category>本站文章书写规范</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文章</tag>
      
      <tag>格式</tag>
      
      <tag>书写规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
