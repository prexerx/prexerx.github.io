<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Terraform Azure Demo开源项目的官方文档</title>
      <link href="2020/11/03/terraform-azure-demo-doc/"/>
      <url>2020/11/03/terraform-azure-demo-doc/</url>
      
        <content type="html"><![CDATA[<div class="note light flat"><p>这是开源项terraform-azure-demo的官方技术文档。</p></div><a id="more"></a><p>开门见山，阅读本文后，你将学会如何使用terraform工具配合HCL语言完成AzureCloud资源配置和构建。</p><p>如果你还不了解如何在项目中真正的使用Azure云，那就耐心的读下去吧，这里浓缩了一个实际项目的方方面面。</p><p>项目传送门 &gt; <a href="https://github.com/prexerx/terraform-azure-demo">terraform-azure-demo</a></p><p>你既然已经找到了这里，肯定是有需求或者想要学习在AzureCloud上自动构建资源的技术，那么我们先来看看这个项目简介和概览。</p><h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p><code>terraform</code>是由<code>Hashicorp</code>公司开源出来的，用于云服务资源部署、规划和管理的工具集。它理论上可以服务于任何云服务商，包括你所知道的云服务几大巨头，如：微软云（AzureCloud），亚马逊（AWS）等。</p><p>本项目主要基于AzureCloud，使用terraform工具来规划和管理AzureCloud上的资源，并构建可用的实用案例。</p><p>该项目真实有效，你几乎只需要修改一小部分，就可以应用到项目中。</p><h2 id="项目概览"><a href="#项目概览" class="headerlink" title="项目概览"></a>项目概览</h2><p>要想尽快的熟悉一个项目，做一个整体的把握是必不可少的，文档的说明就是这个作用，不管是什么样的开源项目，只要它开源出来肯定是希望大家一起能够学习并充实它，让它更富有生命力。</p><p>本项目是一个简单的开源项目，只是一个笔者在工作中浓缩的经验集合，看起来短小的它其实很精悍，毫不夸张的说，如果你完全明白该项目的所有细节，开发一个实际项目是没有什么问题的。</p><p>书归正传，为了让大家有一个更好的理解，笔者打算用框图来表示一个项目的概况，配合着一些简单的讲解，更有助于你快速掌握。</p><p><a href="https://www.processon.com/view/link/5fa0bc996376891d320614ef">项目概览图</a></p><p>基本上所有的内容都有在图上标注，这里强调一些重要概念，可以让你更清楚我们的意图：</p><ul><li><code>顶层模块</code>（Top-Level）是真实的用户可配置的交互模块，但任然可以被用于其他模块的子模块（submodule）</li><li>模块的定义就和你熟悉的函数一样，它具有输入（input variable）和输出（output）</li><li>模块的参数传递都是经过<code>Input variable</code>来完成的，并且和函数式编程类似，它们支持默认值，也支持覆写</li><li>模块的输出都是通过<code>Output</code>来完成的，其他的模块组件内容，对外都不可见</li><li>terraform默认支持远程模块的能力，这就表示我们可以很轻易的使用类似<code>github</code>等远程代码托管仓库中的代码，复用更方便</li><li>terrform配置文件扩展名为<code>.tf</code>，它还有一些其他的文件定义形式，当然也会有不同的作用，项目中使用的<code>*.auto.tfvars</code>就是其中一种，它的作用是覆写顶层模块的参数，其他格式请自行查询terrform的官方文档</li><li>terraform定义模块是和目录结构有关的，一个模块基本上都在同一个目录层级，使用构建指令的时候，并不会在没有引用子模块的时候递归查询子目录</li></ul><p>项目仓库目录树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">prexer $ tree</span><br><span class="line">.</span><br><span class="line">├── backend.tf</span><br><span class="line">├── configs</span><br><span class="line">│   └── hibro-azure.tmpl.yml</span><br><span class="line">├── default.auto.tfvars</span><br><span class="line">├── demo-steps</span><br><span class="line">│   ├── demo.session</span><br><span class="line">│   └── timing.steps</span><br><span class="line">├── LICENSE</span><br><span class="line">├── main.tf</span><br><span class="line">├── Makefile</span><br><span class="line">├── modules</span><br><span class="line">│   ├── moduleDisk</span><br><span class="line">│   │   ├── main.tf</span><br><span class="line">│   │   ├── outputs.tf</span><br><span class="line">│   │   ├── README.md</span><br><span class="line">│   │   └── variables.tf</span><br><span class="line">│   └── moduleNet</span><br><span class="line">│       ├── main.tf</span><br><span class="line">│       ├── outputs.tf</span><br><span class="line">│       ├── README.md</span><br><span class="line">│       └── variables.tf</span><br><span class="line">├── outputs.tf</span><br><span class="line">├── README.md</span><br><span class="line">├── statefile</span><br><span class="line">└── variables.tf</span><br><span class="line"></span><br><span class="line">6 directories, 19 files</span><br></pre></td></tr></table></figure><h2 id="当前复现环境"><a href="#当前复现环境" class="headerlink" title="当前复现环境"></a>当前复现环境</h2><p>截止到现在，这个项目是有效的，后续随着Azure和Terraform项目进行迭代，也许会存在版本兼容的问题，不过在可见的未来，应该大体不会变化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">prexer $ terraform --version</span><br><span class="line">Terraform v0.13.5</span><br><span class="line">+ provider registry.terraform.io&#x2F;hashicorp&#x2F;azurerm v2.34.0</span><br><span class="line">+ provider registry.terraform.io&#x2F;hashicorp&#x2F;null v3.0.0</span><br><span class="line">+ provider registry.terraform.io&#x2F;hashicorp&#x2F;random v3.0.0</span><br><span class="line">+ provider registry.terraform.io&#x2F;hashicorp&#x2F;template v2.2.0</span><br><span class="line"></span><br><span class="line">prexer $ cat &#x2F;proc&#x2F;version</span><br><span class="line">Linux version 4.15.0-1098-azure (buildd@lcy01-amd64-022) (gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.12)) #109~16.04.1-Ubuntu SMP Wed Sep 30 18:53:14 UTC 2020</span><br><span class="line"></span><br><span class="line">prexer $ az version</span><br><span class="line">&#123;</span><br><span class="line">  &quot;azure-cli&quot;: &quot;2.14.0&quot;,</span><br><span class="line">  &quot;azure-cli-core&quot;: &quot;2.14.0&quot;,</span><br><span class="line">  &quot;azure-cli-telemetry&quot;: &quot;1.0.6&quot;,</span><br><span class="line">  &quot;extensions&quot;: &#123;</span><br><span class="line">    &quot;ai-examples&quot;: &quot;0.2.4&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速上手尝鲜"><a href="#快速上手尝鲜" class="headerlink" title="快速上手尝鲜"></a>快速上手尝鲜</h2><p>如果想要使用这个Demo项目，你最少应该进行如下步骤：</p><ol><li>注册一个Azure云账号，可以自己建立或者通过公司的管理者进行开通</li><li>让你的账户所属一个可控的订阅中，一般都是公司或其他组着管控</li><li>获得适当的权限，至少拥有可以创建一定范围内资源的权限</li><li>最后，就是熟悉如何使用Azure门户和Bash Shell</li></ol><p>不过，不管怎么样，微软云都提供了一个免费体验的服务，你可以在微软进行认证后，获得<code>200美金</code>为期<code>一个月</code>的使用权，用来做前期的设计和实践已经足够了。</p><p>然后，登录Azure打开Cloud Bash Shell，然后运行（这是一整个资源的生命周期，按照自己的需求使用相应的指令）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 创建一个临时目录</span></span><br><span class="line">mkdir demo &amp;&amp; cd $_</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 克隆demo示例，并跳转工作目录</span></span><br><span class="line">git clone https://github.com/prexerx/terraform-azure-demo.git &amp;&amp; cd terraform-azure-demo</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 初始化terraform转态文件和一些脚本插件资源</span></span><br><span class="line">make init # or terraform init</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 制定计划，一定要仔细看</span></span><br><span class="line">make plan t=demo</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 应用计划，跟踪输出</span></span><br><span class="line">make apply t=demo</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6. 制定删除计划，请仔细查看每一个细节，避免造成不可恢复的损失</span></span><br><span class="line">make dplan t=demo</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 7. 慎重执行删除操作，除非你知道自己在做什么，否则不要使用</span></span><br><span class="line">make dapply t=demo</span><br></pre></td></tr></table></figure><p>如果你没有功夫注册微软云服务，那你可以通过笔者的示例演示，来回放我在云端操作的细节，复现步骤就是简单的运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> [from] script -t 2&gt; timing.steps -a demo.session</span></span><br><span class="line">scriptreplay demo-steps/timing.steps demo-steps/demo.session</span><br></pre></td></tr></table></figure><p>它会给你展示一个完整的终端交互过程，和你在云端的操作如出一辙。</p><h2 id="快速获取技术帮助"><a href="#快速获取技术帮助" class="headerlink" title="快速获取技术帮助"></a>快速获取技术帮助</h2><p>基本上如果你有一定的编程经验，那完全可以自给自足的完成本Demo的自主构建。</p><p>在寻求帮助的时候，搜索引擎是必不可少的，使用起来你应该已经得心应手了，就像这样：</p><p>如果你不懂<code>resource &quot;azurerm_resource_group&quot;</code>，那么通过搜索引擎来按照关键字查询，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; resource &quot;azurerm_resource_group&quot; site:terraform.io</span><br><span class="line"># or</span><br><span class="line">&gt; terraform resource &quot;azurerm_resource_group&quot;</span><br></pre></td></tr></table></figure><p>详细的定向技术文档会马上呈现在你的面前，你只需要挑选你需要的部分，细心研读即可。</p><h2 id="项目实现细节"><a href="#项目实现细节" class="headerlink" title="项目实现细节"></a>项目实现细节</h2><p>整体把握后，我们来看看具体的实现细节。</p><p>由于我们是基于AzureCloud来配置资源，导致文中不可避免的会多一些AzureCloud的相关说明，不过本着<code>够用即最好</code>的原则，要想使用本项目，只需要了解本文讲解的内容即可。</p><p>为了更好的理解项目内容，模块的划分和文件重心也经过精心的设计，后续实现的说明我们按照指定文件来一步步说明。</p><p>由于terraform是基于<code>HCL语言</code>来进行解释资源的，所以你可以先看看官方的<a href="https://github.com/hashicorp/hcl">语法支持</a>，了解一个大概，基本上这个语言是很好理解的，都是关键字和语句块组成，并配合着命名空间来实现资源的抽象和划分。</p><p>好了，开始看看源码的细节吧！</p><h3 id="backend-tf"><a href="#backend-tf" class="headerlink" title="backend.tf"></a>backend.tf</h3><p><code>backend.tf</code>文件是给<code>terraform</code>工具<code>本身</code>添加自定义配置项的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    azurerm &#x3D; &#123;</span><br><span class="line">      source &#x3D; &quot;hashicorp&#x2F;azurerm&quot;</span><br><span class="line">      version &#x3D; &quot;&gt;&#x3D; 2.26&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider &quot;azurerm&quot; &#123;</span><br><span class="line">  features &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里告诉terraform，我们的后端打算用AzureCloud，在terraform规划的资源管理方面，AzureCloud名称为<code>azurerm</code>也就是<code>Azure Resource Management</code>，并定义了工具的版本参数，它会影响工具的插件集合，所以最好指定一个高阶版本；至于<code>features</code>是AzureCloud等运营商特定的内容，基本上实践项目也没有特别的指定，但又必须实现这个块来使用默认值，所以放在这里也无伤大雅。</p><p>接着迎来了重头戏：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># for Azure backend, you can store your statefile on Azure Cloud.</span><br><span class="line"></span><br><span class="line"># terraform &#123;</span><br><span class="line">#   backend &quot;azurerm&quot; &#123;</span><br><span class="line">#     resource_group_name  &#x3D; &quot;Azure resource group name&quot;</span><br><span class="line">#     storage_account_name &#x3D; &quot;Storage Account in your resource group&quot;</span><br><span class="line">#     container_name       &#x3D; &quot;You should generate a container in your Storage Account, such as: terraform-state&quot;</span><br><span class="line">#     key                  &#x3D; &quot;Terraform Statfile Name, such as: name.terraform.tfstate&quot;</span><br><span class="line">#     access_key           &#x3D; &quot;Storage Account Access Key, you can get it from Azure portal.&quot;</span><br><span class="line">#   &#125;</span><br><span class="line"># &#125;</span><br><span class="line"></span><br><span class="line"># for reference from other resources.</span><br><span class="line"></span><br><span class="line"># data &quot;terraform_remote_state&quot; &quot;hibro&quot; &#123;</span><br><span class="line">#   backend &#x3D; &quot;azurerm&quot;</span><br><span class="line"></span><br><span class="line">#   config &#x3D; &#123;</span><br><span class="line">#     storage_account_name &#x3D; &quot;same as backend azurerm block&quot;</span><br><span class="line">#     container_name       &#x3D; &quot;same as backend azurerm block&quot;</span><br><span class="line">#     key                  &#x3D; &quot;same as backend azurerm block&quot;</span><br><span class="line">#     access_key           &#x3D; &quot;same as backend azurerm block&quot;</span><br><span class="line">#   &#125;</span><br><span class="line"># &#125;</span><br><span class="line"></span><br><span class="line"># Just to teach you with local backend.</span><br><span class="line">terraform &#123;</span><br><span class="line">  backend &quot;local&quot; &#123;</span><br><span class="line">    path &#x3D; &quot;statefile&#x2F;hibro.terraform.tfstate&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># for refer local statefile.</span><br><span class="line"></span><br><span class="line"># data &quot;terraform_remote_state&quot; &quot;hibro_state&quot; &#123;</span><br><span class="line">#   backend &#x3D; &quot;local&quot;</span><br><span class="line"></span><br><span class="line">#   config &#x3D; &#123;</span><br><span class="line">#     path &#x3D; &quot;$&#123;path.module&#125;&#x2F;statefile&#x2F;hibro.terraform.tfstate&quot;</span><br><span class="line">#   &#125;</span><br><span class="line"># &#125;</span><br></pre></td></tr></table></figure><p>关于<code>terraform.backend</code>技术块，它是用来说明terraform的<code>状态文件</code>（名称类似<code>*.terraform.tfstate</code>）将要存储在哪里，也就是说在执行<code>terraform init</code>和<code>terraform apply</code>指令的时候，前者会找到存储位置然后进行后续资源的判定，而后者也是由于前面资源的判定，进而决定哪些资源需要创建、修改或者删除等操作。</p><p>后端存储基本分为两种：</p><ol><li>本地存储，这也是默认行为，如果你不配置它会存储在你本地的当前工作目录</li><li>远程存储，你可以根据需求存储terraform状态文件到远程位置，如：微软的存储账户，或者github等地方。</li></ol><p>我们为了方便演示，将状态文件存储在本地指定的目录位置：<code>statefile/</code>(相对目录)，并且命名为<code>hibro.terraform.tfstate</code></p><p>存储在远程的位置也是很简单的，如图所示，获取远程资源后，一次填写配置即可：（我们假设你已经构建了一个存储账户）</p><p><img src="/images/blog-images/azure_terraform_backend.png" alt="Azure上获得配置"></p><p>至于<code>container_name</code>需要在Azure上创建一个，当然Azure提供了<code>az</code>指令可以完成这个工作，不过我们演示下从web界面操作的方法：</p><p><img src="/images/blog-images/azure_storage_container_create.png" alt="在存储账户上创建容器"></p><p>至于剩下的<code>data.terraform_remote_state</code>块，是作引用你存储过的状态文件之用；也就是说在引用之前，你的文件一定是存在的，当然它也对应着远程和本地位置，如果状态文件不存在，terraform会报错提示你找不到相应的状态文件。</p><p>对于<code>backend = &quot;azurerm&quot;/&quot;local&quot;</code>引用块来说，这部分说明你要引用的后端位置，其他的配置基本上和前文配置的存储位置一致。</p><p>你也不用诧异，很多时候，这个状态文件是作为terraform的枢纽一样的存在，它可以帮助你存贮资源的概况，甚至作为其他资源的输入部分，只要引用它，就可以得到它的所有输出。</p><h3 id="default-auto-tfvars"><a href="#default-auto-tfvars" class="headerlink" title="default.auto.tfvars"></a>default.auto.tfvars</h3><p>前文已经提到，terraform支持很多扩展文件名，如<code>.tf</code>,<code>.auto.tfvars</code>等，其他格式去terraform官网看看吧，这里就不展开介绍了。</p><p>对于本项目中的<code>default.auto.tfvars</code>文件来说，它的作用是覆写默认的顶层模块配置参数值。</p><p>首先你必须知道，在default.auto.tfvars文件中配置的值，一定要在<code>variable.tf</code>文件中也定义，否则你去覆写谁呢？而且按照前文的描述，模块的输入都是通过<code>input variable</code>来完成的，对应的部分就是<code>variable.tf</code>文件中的内容。</p><p>这里再说明下，一个模块（限定一个模块）的所有资源都可以写到一个文件中，就算写到不同的<code>tf文件</code>中，最后terraform也会整合到一起；terraform的做法是，解析当前模块目录中的所有<code>tf文件</code>，并不递归解析；不过对于复杂的项目来说，根据文件来区分重要的部分，可以更清晰的了解项目细节，而且这也是terraform官方推荐的做法。</p><p>文件中的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">prefix   &#x3D; &quot;hibro&quot;</span><br><span class="line">location &#x3D; &quot;westus2&quot;</span><br><span class="line"></span><br><span class="line">os_publisher &#x3D; &quot;kinvolk&quot;</span><br><span class="line">os_offer     &#x3D; &quot;flatcar-container-linux-free&quot;</span><br><span class="line">os_sku       &#x3D; &quot;stable&quot;</span><br><span class="line">os_version   &#x3D; &quot;latest&quot;</span><br><span class="line"></span><br><span class="line">admin_username &#x3D; &quot;core&quot;</span><br><span class="line">admin_password &#x3D; &quot;disable for flatcar OS&quot;</span><br><span class="line">admin_pub_key  &#x3D; &quot;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCorWm8FA4ovqbqWGQgoQ2QJo+CuFK7Dr8Zujen6iQVCWaWx&#x2F;2oCGOi4sgpwAt9H5zfXFBag7eXrG9lL4DE3W5GONmcdn4v8fA0AASORu++mUfLBN3YjcQAudRQLlOtVYVaHTRbL2jiXBHuNvZjkrH1EyCKPdAZEPWauGOE4CXtE&#x2F;e0Qlcb9i&#x2F;rK7Eqm3b7&#x2F;BzbUiNUJv1XpLFuJFSR5YugnSzBxkghvsyz4oOsbJ65pwPgwCGI1gsECcQ3WN93REwekOOedIONRlEzbp6KCCWWAf9rFD4E++INQAvmB+Js8X1WxWydeq3NWHMmFNDLRqAuUnyvsVzVwwBSdlNPJVzb&quot;</span><br></pre></td></tr></table></figure><p>这和你们接触过的，如<code>定义变量</code>，出奇的一致，不是么？只不过terraform支持的类型基本和python或者json类似，这里也不过多说明，后续我们会用到字符串、布尔变量、列表、字典和对象等类型。</p><h3 id="variable-tf（顶层输入）"><a href="#variable-tf（顶层输入）" class="headerlink" title="variable.tf（顶层输入）"></a>variable.tf（顶层输入）</h3><p>这里我们就顶层模块的输入部分来说明，它的官方说法是<code>input variable</code>，不过本文对于<code>input variable</code>和<code>variable</code>并不区分。</p><p>由于篇幅限制，我们只讲解重点说明的部分，截取部分代码，后续也是如此，如果要看详细配置，请自行克隆项目源码，它并不多，不是么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">variable &quot;admin_username&quot; &#123;</span><br><span class="line">    type &#x3D; string</span><br><span class="line">    description &#x3D; &quot;Administrator user name for virtual machine&quot;</span><br><span class="line">    default &#x3D; &quot;hibro&quot;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">## a map for tags</span><br><span class="line">variable &quot;tags&quot; &#123;</span><br><span class="line">    type &#x3D; map</span><br><span class="line">    default &#x3D; &#123;</span><br><span class="line">        hibroTags &#x3D; &quot;Terraform Demo with Tags&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里仅仅列举两种变量类型，字符串和字典，当然布尔值、列表和其他类型也很简单，自行查询文档就可以了。</p><p>对于<code>variable.xxx</code>块来说，后面的<code>xxx</code>部分就是变量的名字，也是别人引用的变量名称，不过这里有一点需要注意，以往的引用都是一个完整的命名空间前缀，如：<code>data.terraform.backend</code>这样，而对于变量的引用却有些不同，应该使用<code>var.xxx</code>来完成。</p><blockquote><p> type &lt; 变量中可以存在类型的强定义，如果没有定义那么terraform会自行推导。</p></blockquote><blockquote><p>description &lt; 变量的解释说明，由于这是一门DSL，所以它的解释说明对于一个资源来说是有需要的，但不是必要的</p></blockquote><blockquote><p>default &lt; 变量的默认值，如果没有传入变量值，则会使用默认值，如果没有默认值又没有传入变量，则会报错</p></blockquote><blockquote><p><code>type = map</code>定义一个字典变量，就是你理解的键值对，并没有什么特别，嵌套和对象的引用和你熟悉的语言类似</p></blockquote><h3 id="main-tf-顶层主要配置"><a href="#main-tf-顶层主要配置" class="headerlink" title="main.tf(顶层主要配置)"></a>main.tf(顶层主要配置)</h3><p>这部分当之无愧是重头戏，所有资源的布局和调配基本都起源于它；那么我们需要完全的引用它的内容，并在代码中以详细的注释来说明它的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Create a Top Level Resource Group 怎么看都是注释，不是么？</span><br><span class="line"># 定义一个资源组，名称为&quot;rg&quot;,引用名称为&#39;azurerm_resource_group.rg&#39;</span><br><span class="line"># 这里和常用的命名空间也有所不同，不用带有&#39;resource&#39;关键字</span><br><span class="line">resource &quot;azurerm_resource_group&quot; &quot;rg&quot; &#123; </span><br><span class="line">  name     &#x3D; &quot;$&#123;var.prefix&#125;-RG&quot; # 资源组的名字</span><br><span class="line">  # 资源组所在位置，也就是说你的资源组应该建立在哪里，如美国西部（westus）或者欧洲（europe）等</span><br><span class="line">  # 同样的，它会关联你的其他资源，他们需要放在一起，跨域很多时候是不行的！</span><br><span class="line">  location &#x3D; var.location </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Generate random text for a unique storage account name</span><br><span class="line"># terraform内置的资源，可以帮忙随机产生一个随机8位ID，用于后续的存贮账户命名</span><br><span class="line">resource &quot;random_id&quot; &quot;randomId&quot; &#123;</span><br><span class="line">    keepers &#x3D; &#123; # 持有者为前文定义的资源组</span><br><span class="line">        resource_group &#x3D; azurerm_resource_group.rg.name</span><br><span class="line">    &#125;</span><br><span class="line">    # 随机字符数目</span><br><span class="line">    byte_length &#x3D; 8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Create storage account for boot diagnostics</span><br><span class="line"># 创建一个存储账户，名称为sa</span><br><span class="line">resource &quot;azurerm_storage_account&quot; &quot;sa&quot; &#123;</span><br><span class="line"># 存储账户的名字，它必须是AzureCloud上唯一的，所以使用了一个字符串拼接的技巧，并且内部扩展了变量，引用了之前生成的随机ID</span><br><span class="line">    name                        &#x3D; &quot;hibro$&#123;random_id.randomId.hex&#125;&quot;</span><br><span class="line">    # 所属资源组，后续不再说明</span><br><span class="line">    resource_group_name         &#x3D; azurerm_resource_group.rg.name</span><br><span class="line">    # 资源所处位置，后续不再说明</span><br><span class="line">    location                    &#x3D; var.location</span><br><span class="line">    # 存储账户的天梯榜，也就是性能，分为：Standard and Premium</span><br><span class="line">    account_tier                &#x3D; &quot;Standard&quot;</span><br><span class="line">    # 定义用于此存储帐户的复制类型，也是默认值</span><br><span class="line">    account_replication_type    &#x3D; &quot;LRS&quot;</span><br><span class="line"># 自定义的资源标签，用于处理对象关系，这里的类型是一个字典</span><br><span class="line">    tags &#x3D; &#123;</span><br><span class="line">        uAwesomeAccount &#x3D; &quot;hibro-Account&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 引用一个submodule，注意，这不是定义，而是引用模块的写法</span><br><span class="line">module &quot;hibroNet&quot; &#123; # 引用模块后，在本模块中定义了一个别名，为&#96;module.hibroNet&#96;</span><br><span class="line">  # 引用外部子模块的语法，这是引用本地模块的语法，解析了相对于当前模块位置的其他模块，如 moduleNet</span><br><span class="line">  source &#x3D; &quot;.&#x2F;modules&#x2F;moduleNet&quot; </span><br><span class="line"></span><br><span class="line">  # 模块变量的参数传递，有时候我们会根据自己的需要修改引用模块的参数，这里就是一个方案</span><br><span class="line">  # 需要注意的是，这里的参数定义和引用模块的参数定义是对应的，子模块必须定义这些变量才行！</span><br><span class="line">  prefix &#x3D; var.prefix # 一个项目特定的前缀，后文都是一样的&#96;hibro-&#96;</span><br><span class="line">  location &#x3D; azurerm_resource_group.rg.location</span><br><span class="line">  resource_group &#x3D; azurerm_resource_group.rg.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module &quot;hibroDisk&quot; &#123;</span><br><span class="line">  source &#x3D; &quot;.&#x2F;modules&#x2F;moduleDisk&quot; # 引用本地子模块moduleDisk</span><br><span class="line"></span><br><span class="line">  prefix &#x3D; var.prefix</span><br><span class="line">  location &#x3D; azurerm_resource_group.rg.location</span><br><span class="line">  resource_group &#x3D; azurerm_resource_group.rg.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module &quot;hibroRemote&quot; &#123;</span><br><span class="line">  # 引用远程子模块，它位于github上，在terraform init的时候会导入它到本地，本质上和本地差不多。</span><br><span class="line">  # 语法形式为官方提供，只需要按照标准书写即可</span><br><span class="line">  source &#x3D; &quot;git::https:&#x2F;&#x2F;github.com&#x2F;prexerx&#x2F;terraform-remote-module.git&quot;</span><br><span class="line"></span><br><span class="line">  prefix &#x3D; var.prefix</span><br><span class="line">  location &#x3D; azurerm_resource_group.rg.location</span><br><span class="line">  resource_group &#x3D; azurerm_resource_group.rg.name</span><br><span class="line">  # 这里的技巧和其他的不同，这里使用了前文的&#96;module.hibroNet&#96;模块的输出，并用它的ID来作为远程模块的输入</span><br><span class="line">  # 默认的，它也就说明了一种依赖关系，说明远程模块(hibroRemote)资源的构建需要依赖本地模块(hibroNet)的资源，先后顺序一目了然</span><br><span class="line">  subnet_id &#x3D; module.hibroNet.subnet_id # 这也是一种对象类型</span><br><span class="line"></span><br><span class="line">  depends_on &#x3D; [ # 如果没有显示的资源依赖关系定义，那么就需要使用这个关键字段来说明，这是一个列表对象，用逗号分隔所依赖的资源</span><br><span class="line">    azurerm_resource_group.rg</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Create a Linux virtual machine</span><br><span class="line"># 创建一个虚拟机，有很多的官方资源关键字可以使用，不过我们就以&#96;azurerm_virtual_machine&#96;说明，其他都类似</span><br><span class="line">resource &quot;azurerm_virtual_machine&quot; &quot;vm&quot; &#123; # 虚拟机资源定义别名</span><br><span class="line">  name                  &#x3D; &quot;hibro-VM&quot; # 虚拟机资源的名字</span><br><span class="line">  location              &#x3D; azurerm_resource_group.rg.location</span><br><span class="line">  resource_group_name   &#x3D; azurerm_resource_group.rg.name</span><br><span class="line">  network_interface_ids &#x3D; [module.hibroRemote.nic_id] # 附着在虚拟机上的网卡列表，一台机器多个网卡很常见不是么？</span><br><span class="line">  primary_network_interface_id &#x3D; module.hibroRemote.nic_id # 主网卡标记</span><br><span class="line"></span><br><span class="line">  vm_size               &#x3D; var.vm_size # 这很重要，表示你使用了一个什么性能虚拟机，它包括类似CPU，内存，缓存等相关的资源，计费也是比较可观的，所以请根据自己的需求，查看官方文档后来选择</span><br><span class="line"></span><br><span class="line">  # 当删除虚拟机的时候也删除系统盘</span><br><span class="line">  delete_os_disk_on_termination &#x3D; true</span><br><span class="line"></span><br><span class="line">  boot_diagnostics &#123; # 调试块，还有很多参数，不过我们只关心虚拟机开机启动的调试log</span><br><span class="line">    enabled     &#x3D; var.debug_enable # 使能调试</span><br><span class="line">    # 指定log的存储位置，这里存储在我们前文创建的存储账户中了，所有的开机log都在那里！</span><br><span class="line">    storage_uri &#x3D; azurerm_storage_account.sa.primary_blob_endpoint</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  storage_os_disk &#123; # 构建虚拟机操作系统镜像的磁盘</span><br><span class="line">    name              &#x3D; &quot;$&#123;var.prefix&#125;-OsDisk&quot; # 系统盘的名字</span><br><span class="line">    caching           &#x3D; &quot;ReadWrite&quot; # 缓存形式，这些概念需要你有一些操作系统方面的知识</span><br><span class="line">    create_option     &#x3D; &quot;FromImage&quot; # 从ISO创建，就这样，目前Flatcar也通常是使用这种方法来配置的，AzureCloud会帮你拉取ISO镜像</span><br><span class="line">    managed_disk_type &#x3D; &quot;Premium_LRS&quot; # 磁盘的性能，也是查表获取的内容，关键字直接查询即可，而且你还会看到不同的价格表</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  storage_image_reference &#123; # 操作系统的引用说明，它目前需要配合plan来说明</span><br><span class="line">    publisher &#x3D; var.os_publisher # Flatcar的发布者</span><br><span class="line">    offer     &#x3D; var.os_offer # Flatcar的提供方</span><br><span class="line">    sku       &#x3D; var.os_sku # 版本属性，如stable，next等</span><br><span class="line">    version   &#x3D; var.os_version # 版本导航，如latest或者2516.2等</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  plan &#123; # 目前，我们配合前文storage_image_reference来说明计划，配置内容和前面一样，否则会报错</span><br><span class="line">    name      &#x3D; var.os_sku</span><br><span class="line">    publisher &#x3D; var.os_publisher</span><br><span class="line">    product   &#x3D; var.os_offer</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  storage_data_disk &#123; # 挂载外部磁盘</span><br><span class="line">  # 引用了本地模块hibroDisk的属性，如名字和ID，还有后文的磁盘大小</span><br><span class="line">    name            &#x3D; module.hibroDisk.disk_touchMeStorage_name</span><br><span class="line">    managed_disk_id &#x3D; module.hibroDisk.disk_touchMeStorage_id</span><br><span class="line">    create_option   &#x3D; &quot;Attach&quot; # 挂接</span><br><span class="line">    lun             &#x3D; 0 # 磁盘在VM中的唯一编号</span><br><span class="line">    disk_size_gb    &#x3D; module.hibroDisk.disk_touchMeStorage_size</span><br><span class="line">    caching         &#x3D; &quot;ReadOnly&quot; # 磁盘的缓存属性为只读，但不是磁盘只读，说明缓存不能被动态写入而已</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  storage_data_disk &#123;</span><br><span class="line">    name            &#x3D; module.hibroDisk.disk_hitMeStorage_name</span><br><span class="line">    managed_disk_id &#x3D; module.hibroDisk.disk_hitMeStorage_id</span><br><span class="line">    create_option   &#x3D; &quot;Attach&quot;</span><br><span class="line">    lun             &#x3D; 1 # 磁盘在VM中的唯一编号</span><br><span class="line">    disk_size_gb    &#x3D; module.hibroDisk.disk_hitMeStorage_size</span><br><span class="line">    caching         &#x3D; &quot;ReadWrite&quot; # 另一种缓存属性，它说明可以支持动态修改缓存，不过对于系统来说只有操作系统视图有用</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  os_profile &#123; # 操作系统的规划配置</span><br><span class="line">    computer_name  &#x3D; &quot;hibro-VM&quot; # 主机名</span><br><span class="line">    admin_username &#x3D; var.admin_username # 有管理权限的用户名</span><br><span class="line">    # admin_password &#x3D; var.admin_password # (login with ssh public key) # 定义密码</span><br><span class="line">    # 配置文件渲染后的输出，这里需要重点说明下</span><br><span class="line">    # 这里引用了后文的配置文件对象，并且它会把渲染后的文件放到VM中的指定位置：&#x2F;var&#x2F;lib&#x2F;waagent&#x2F;CustomData</span><br><span class="line">    # 这里有一个[0],说明资源hibro_config是有count属性的，索引从0开始</span><br><span class="line">    custom_data    &#x3D; data.template_file.hibro_config[0].rendered</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  os_profile_linux_config &#123; # 这是类似的扩展配置内容，看起来是后续加的，不过我们只关心内容就可以</span><br><span class="line">    # disable_password_authentication &#x3D; false # (login with ssh public key) # 如果配置密码，那后面的内容就需要注释掉</span><br><span class="line">    disable_password_authentication &#x3D; true # 不使用密码，由于flatcar的特殊性，请使用SSH Key来登陆管理用户</span><br><span class="line">    ssh_keys &#123; </span><br><span class="line">      # 配置VM中存储你要传入的SSH pub key的地方</span><br><span class="line">      path     &#x3D; &quot;&#x2F;home&#x2F;$&#123;var.admin_username&#125;&#x2F;.ssh&#x2F;authorized_keys&quot;</span><br><span class="line">      # 你传入的SSH pub key值，用对应的私钥解密，对么？</span><br><span class="line">      key_data &#x3D; var.admin_pub_key</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tags &#x3D; var.tags # 直接应用map类型变量的例子</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># terraform官方提供的渲染文件的模板关键字&#96;template_file&#96;</span><br><span class="line">data &quot;template_file&quot; &quot;hibro_config&quot; &#123;</span><br><span class="line">  count &#x3D; 1 # 定义了一个count属性，后续医用资源的时候从0开始</span><br><span class="line">  # 模板文件的位置，file是terraform内置的函数获得文件，&#96;path.module&#96;为内置的变量，指定当前模块的目录位置</span><br><span class="line">  template &#x3D; file(&quot;$&#123;path.module&#125;&#x2F;configs&#x2F;hibro-azure.tmpl.yml&quot;)</span><br><span class="line"></span><br><span class="line">  vars &#x3D; &#123; # 渲染文件中的变量替换，好奇么？看看&#96;configs&#x2F;hibro-azure.tmpl.yml&#96;文件你就明白了</span><br><span class="line">    hibro_vm_ip_address &#x3D;  module.hibroRemote.public_ip_address</span><br><span class="line">    others_environment  &#x3D; &quot;hibro hacker&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 这依旧是terraform定义的一个内置资源类型，它和其他的资源一样，只不过没有实体对应，就进行一些操作而已。</span><br><span class="line"># 这里通过这个资源来对已经启动的VM进行一些操作</span><br><span class="line">resource &quot;null_resource&quot; &quot;hibro_config_update&quot; &#123;</span><br><span class="line"></span><br><span class="line">  triggers &#x3D; &#123;</span><br><span class="line">  # 定义一个触发资源更新的条件，这是对于&#96;terraform状态文件&#96;使用的而言的，如果文件更新了，资源才会再次操作</span><br><span class="line">    template_rendered &#x3D; data.template_file.hibro_config[0].rendered</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  connection &#123; # 定义连接到虚拟机的方式</span><br><span class="line">    type &#x3D; &quot;ssh&quot; # 通过该ssh协议</span><br><span class="line">    user &#x3D; &quot;core&quot; # 用户名，这里之所以没有写变量是因为提醒用户，对于Flatcar而言core通常就是默认的用户</span><br><span class="line">    # Azure CloudShell Must use Public IP Address to access the VM.</span><br><span class="line">    # 这里比较有意思，后面会详细的说明，这里你只需要知道是对一个远程模块定义的Public IP的引用即可</span><br><span class="line">    host &#x3D; module.hibroRemote.public_ip_address</span><br><span class="line">    # Azure CloudShell SSH Private Key location!</span><br><span class="line">    # Azure CloudShell的私钥存放位置，对应的肯定是公钥</span><br><span class="line">    private_key &#x3D; file(&quot;~&#x2F;.ssh&#x2F;id_rsa&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  provisioner &quot;file&quot; &#123; # 就是说明要干什么，file表示创建一个文件</span><br><span class="line">    # 内容是前文的渲染后版本</span><br><span class="line">    content     &#x3D; data.template_file.hibro_config[0].rendered</span><br><span class="line">    # 文件的写入位置和文件名称</span><br><span class="line">    destination &#x3D; &quot;&#x2F;tmp&#x2F;hibro-update&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  provisioner &quot;remote-exec&quot; &#123; # remote-exec 说明要执行一些指令，就是你认为的常见的linux指令</span><br><span class="line">    inline &#x3D; [ # 指定的指令集合，以列表的形式说明</span><br><span class="line">      &quot;whoami &amp;&amp; ls &#x2F;tmp&#x2F; -l&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  # 需要虚拟机已经创建好才能进行操作，不是么？</span><br><span class="line">  depends_on &#x3D; [azurerm_virtual_machine.vm]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此项目的所有资源都是统一前缀为<code>hibro-</code>，这只是一个自定义设计而已，但对于隔绝其他的命名空间，简单且有效。</p><p>模块在引用时，都会带着命名空间前缀<code>module</code>，类似<code>module.xxx.xxx</code>。</p><p>资源的创建有一定的依赖关系，terraform可以自行推导显示指定的依赖关系，不过如果没有显示指定的资源又产生了依赖，那么在并行创建的时候就会出现问题，所以有时候我们需要使用<code>depends_on</code>字段来说明资源的依赖关系。</p><p>拥有<code>count</code>属性的资源，是允许用户创建多个类似资源的快捷方式，引用的时候需要一些额外技巧，通过<code>[0]</code>的方式来引用，count定义的时候是从1开始，而引用的时候从0开始。</p><p>Terraform内置的函数和变量需要参考官方的技术手册，<a href="https://www.terraform.io/docs/configuration/functions.html">走你</a> 。</p><p>需要知道的是，Azure CloudShell也是Azure给你提供的一个ubuntu虚拟机的bash shell伪终端而已，它也依附于一个系统之上，并没有多么神秘。</p><p>配置中有一项<code>host = module.hibroRemote.public_ip_address</code>要说明下，默认情况下Azure Cloudshell访问Azure自建虚拟机是有限制的，首先如果你的Azure Cloudshell没有和自建虚拟机在同一个网段，那么他们不能彼此访问，如果需要通过Azure CloudShell访问虚拟机，那就需要VM有一个挂接的公网IP，之后通过公网IP就可以通讯，当然Azure也提供了将Azure Cloud Shell并入你公司内网的方案，请自行查看官方文档以寻求帮助。</p><p>还有一点请注意，在Azure虚拟机中想要通过指令<code>ping</code>来测试连通性，比如从Azure VM到Azure CloudShell ubuntu是不行的，Azure官方有对ICMP协议的限制。</p><h3 id="output-tf（顶层输出）"><a href="#output-tf（顶层输出）" class="headerlink" title="output.tf（顶层输出）"></a>output.tf（顶层输出）</h3><p>对于顶层模块的输出，你可以灵活的进行配置，各种资源的输出你都可以尝试，我们的Demo只提供了一个条欢迎信息和一个有用的自动构建的虚拟机公网IP地址，如果你要使用当前登录，只需要知道公钥/私钥如何匹配，然后运行：<code>ssh core@&lt;vm_public_ip&gt;</code>即可完成登录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Top-Level Output</span><br><span class="line">output &quot;Hi_Bro_From_Author&quot; &#123;</span><br><span class="line">value &#x3D; &quot;Nice to meet you, any question, file to &lt; prexer.163.com &gt; | .. ^_^ .. &quot;</span><br><span class="line">&#125;</span><br><span class="line">output &quot;hibro_vm_public_ip&quot; &#123;</span><br><span class="line">value &#x3D; module.hibroRemote.public_ip_address</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子模块的讲解部分"><a href="#子模块的讲解部分" class="headerlink" title="子模块的讲解部分"></a>子模块的讲解部分</h2><p>后文是对于子模块的讲解部分，每个模块内容比较少，所以我们把一个模块作为一个整体来阐述细节。</p><h3 id="moduleDisk"><a href="#moduleDisk" class="headerlink" title="moduleDisk"></a>moduleDisk</h3><p>模块的内容如下，我们依旧通过注释详解的方式来讲述案例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"># variable.tf</span><br><span class="line"># 这里承接顶层模块的参数传递，如果不传入，就会报错！</span><br><span class="line">variable &quot;prefix&quot; &#123;</span><br><span class="line">    type &#x3D; string</span><br><span class="line">&#125;</span><br><span class="line">variable &quot;location&quot; &#123;</span><br><span class="line">    type &#x3D; string</span><br><span class="line">&#125;</span><br><span class="line">variable &quot;resource_group&quot; &#123;</span><br><span class="line">    type &#x3D; string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># main.tf</span><br><span class="line"># 定义一个磁盘资源</span><br><span class="line">resource &quot;azurerm_managed_disk&quot; &quot;touchMeStorage&quot; &#123;</span><br><span class="line">  name                 &#x3D; &quot;$&#123;var.prefix&#125;-touchMe-storage&quot; # 磁盘资源的名字</span><br><span class="line">  location             &#x3D; var.location</span><br><span class="line">  resource_group_name  &#x3D; var.resource_group</span><br><span class="line">  storage_account_type &#x3D; &quot;Premium_LRS&quot; # 磁盘的性能指标，查看Azure官网就可以了</span><br><span class="line">  create_option        &#x3D; &quot;Copy&quot; # 这里说明从其他磁盘拷贝一个完整的镜像到自己身上</span><br><span class="line">  # 只有当&#96;create_option&#96;为&#96;Copy&#96;的时候才会有这个属性，它说明从哪里拷贝数据</span><br><span class="line">  source_resource_id   &#x3D; azurerm_managed_disk.copyMeStorage.id</span><br><span class="line">  disk_size_gb         &#x3D; &quot;8&quot; # 磁盘的大小，单位我就不用细说了吧...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;azurerm_managed_disk&quot; &quot;hitMeStorage&quot; &#123;</span><br><span class="line">  #count               &#x3D; 1 # 磁盘可以有多个分身，不是么？批量的话，可以试试count属性</span><br><span class="line">  name                 &#x3D; &quot;$&#123;var.prefix&#125;-hitMe-Storage&quot;</span><br><span class="line">  location             &#x3D; var.location</span><br><span class="line">  resource_group_name  &#x3D; var.resource_group</span><br><span class="line">  storage_account_type &#x3D; &quot;StandardSSD_LRS&quot;</span><br><span class="line">  create_option        &#x3D; &quot;Empty&quot; # 这个属性说明磁盘建立的时候是空的，也说明它的建立非常快速，不是么？</span><br><span class="line">  disk_size_gb         &#x3D; &quot;8&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># no use, just to be copied, don&#39;t export out.</span><br><span class="line"># 这里也有注释说明，这个磁盘资源并没有被使用，而是作为一个替身，被别人复制了！其他的并没有什么特殊</span><br><span class="line">resource &quot;azurerm_managed_disk&quot; &quot;copyMeStorage&quot; &#123;</span><br><span class="line">  name                 &#x3D; &quot;$&#123;var.prefix&#125;-copyMe-Storage&quot;</span><br><span class="line">  location             &#x3D; var.location</span><br><span class="line">  resource_group_name  &#x3D; var.resource_group</span><br><span class="line">  storage_account_type &#x3D; &quot;Premium_LRS&quot;</span><br><span class="line">  create_option        &#x3D; &quot;Empty&quot;</span><br><span class="line">  disk_size_gb         &#x3D; &quot;8&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># output.tf</span><br><span class="line"># 这部分是该子模块的输出，而顶层模块也只能引用它的输出部分，并不能看见它的内部结构。</span><br><span class="line"># 引用的时候应该类似：module.&lt;alias_name&gt;.disk_touchMeStorage_name</span><br><span class="line">output &quot;disk_touchMeStorage_name&quot; &#123;</span><br><span class="line">    value &#x3D; azurerm_managed_disk.touchMeStorage.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &quot;disk_touchMeStorage_id&quot; &#123;</span><br><span class="line">    value &#x3D; azurerm_managed_disk.touchMeStorage.id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &quot;disk_touchMeStorage_size&quot;&#123;</span><br><span class="line">    value &#x3D; azurerm_managed_disk.touchMeStorage.disk_size_gb</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &quot;disk_hitMeStorage_name&quot; &#123;</span><br><span class="line">    value &#x3D; azurerm_managed_disk.hitMeStorage.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &quot;disk_hitMeStorage_id&quot; &#123;</span><br><span class="line">    value &#x3D; azurerm_managed_disk.hitMeStorage.id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &quot;disk_hitMeStorage_size&quot;&#123;</span><br><span class="line">    value &#x3D; azurerm_managed_disk.hitMeStorage.disk_size_gb</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="moduleNet"><a href="#moduleNet" class="headerlink" title="moduleNet"></a>moduleNet</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"># variable.tf</span><br><span class="line"># 必要的传入参数，你懂的</span><br><span class="line">variable &quot;prefix&quot; &#123;</span><br><span class="line">    type &#x3D; string</span><br><span class="line">&#125;</span><br><span class="line">variable &quot;location&quot; &#123;</span><br><span class="line">    type &#x3D; string</span><br><span class="line">&#125;</span><br><span class="line">variable &quot;resource_group&quot; &#123;</span><br><span class="line">    type &#x3D; string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># main.tf</span><br><span class="line"># 网络资源部分的讲解在本文不会涉猎太多，因为如果要说明它，可能要一本书才能完成，请自行查阅资料。</span><br><span class="line"># 当然必要的简单描述还是有必要的！</span><br><span class="line"># Create virtual network</span><br><span class="line"># 定义一个虚拟网络，网络拓扑应该是这样的关系</span><br><span class="line"># vnet -&gt; subnet(with mask) -&gt; private ip</span><br><span class="line">resource &quot;azurerm_virtual_network&quot; &quot;vnet&quot; &#123; </span><br><span class="line">  name                &#x3D; &quot;$&#123;var.prefix&#125;-Vnet&quot;</span><br><span class="line">  address_space       &#x3D; [&quot;10.0.0.0&#x2F;16&quot;] # 虚拟网络的网段定义</span><br><span class="line">  location            &#x3D; var.location # 这里强调下网络的配置，之前提到过跨域的资源访问，网络资源是绝对不能跨地域来访问的，不然要VPN干嘛？</span><br><span class="line">  resource_group_name &#x3D; var.resource_group</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Create subnet</span><br><span class="line"># 定义一个子网网段</span><br><span class="line">resource &quot;azurerm_subnet&quot; &quot;subnet&quot; &#123;</span><br><span class="line">  name                 &#x3D; &quot;$&#123;var.prefix&#125;-Subnet&quot;</span><br><span class="line">  resource_group_name  &#x3D; var.resource_group</span><br><span class="line">  virtual_network_name &#x3D; azurerm_virtual_network.vnet.name # 所属的虚拟网络，正好是我们前面创建额</span><br><span class="line">  address_prefixes     &#x3D; [&quot;10.0.1.0&#x2F;24&quot;] # 子网网段，&#96;10.0.1.0&#96;是符合私用标准的范围，免费内网使用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Create Network Security Group and rule</span><br><span class="line"># 定义一个网络安全组，它其实是说明为了网络安全，哪些端口，或者协议可以开放，进行更细粒度的限制</span><br><span class="line">resource &quot;azurerm_network_security_group&quot; &quot;nsg&quot; &#123;</span><br><span class="line">  name                &#x3D; &quot;$&#123;var.prefix&#125;-NSG&quot;</span><br><span class="line">  location            &#x3D; var.location</span><br><span class="line">  resource_group_name &#x3D; var.resource_group</span><br><span class="line"></span><br><span class="line">  security_rule &#123; # 定义一个安全规则</span><br><span class="line">    name                       &#x3D; &quot;SSH&quot; # 开通SSH协议</span><br><span class="line">    priority                   &#x3D; 1001 # 优先级，当不同协议被定义的时候，数据被截获的顺序和优先级有关</span><br><span class="line">    direction                  &#x3D; &quot;Inbound&quot; # 输入方向</span><br><span class="line">    access                     &#x3D; &quot;Allow&quot;</span><br><span class="line">    protocol                   &#x3D; &quot;Tcp&quot; # 传输层协议</span><br><span class="line">    source_port_range          &#x3D; &quot;*&quot; # 所有地址都可以访问</span><br><span class="line">    destination_port_range     &#x3D; &quot;22&quot; # SSH标准端口</span><br><span class="line">    source_address_prefix      &#x3D; &quot;*&quot; # 没有地址前缀限制</span><br><span class="line">    destination_address_prefix &#x3D; &quot;*&quot; # 目标地址也没哟前缀限制</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># output.tf</span><br><span class="line"># 这是网络模块的输出部分，它对外给虚拟机的网卡输出一个&#96;SUBNET ID&#96;，来让网卡可以挂到我们创建的子网上面。</span><br><span class="line">output &quot;subnet_id&quot; &#123;</span><br><span class="line">    value &#x3D; azurerm_subnet.subnet.id</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="moduleRemote"><a href="#moduleRemote" class="headerlink" title="moduleRemote"></a>moduleRemote</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"># variable.tf</span><br><span class="line">variable &quot;prefix&quot; &#123;</span><br><span class="line">    type &#x3D; string</span><br><span class="line">&#125;</span><br><span class="line">variable &quot;location&quot; &#123;</span><br><span class="line">    type &#x3D; string</span><br><span class="line">&#125;</span><br><span class="line">variable &quot;resource_group&quot; &#123;</span><br><span class="line">    type &#x3D; string</span><br><span class="line">&#125;</span><br><span class="line"># 由于这个模块我们要绑定网卡到子网上，所以需要传入外部已经定义好的子网ID</span><br><span class="line">variable &quot;subnet_id&quot; &#123;</span><br><span class="line">    type &#x3D; string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># main.tf</span><br><span class="line"># Create public IP</span><br><span class="line"># 申请一个public ip资源</span><br><span class="line">resource &quot;azurerm_public_ip&quot; &quot;publicip&quot; &#123;</span><br><span class="line">  name                &#x3D; &quot;$&#123;var.prefix&#125;-PublicIP&quot;</span><br><span class="line">  location            &#x3D; var.location</span><br><span class="line">  resource_group_name &#x3D; var.resource_group</span><br><span class="line">  allocation_method   &#x3D; &quot;Static&quot; # 分配一个静态IP地址，只有两种类型&#96;dynamic&#96;和&#96;static&#96;</span><br><span class="line">&#125;</span><br><span class="line"># 当外部想要引用资源的未导出数据时，需要定义一个同名的data资源块，然后完成引用</span><br><span class="line"># 需要知道，有些资源的数据在没有导出的时候是不能引用的，也就是你看不见，这种方法也是官方推荐的！</span><br><span class="line"># 你需要的只是定义一个同名块，然后填写必要的数据即可。</span><br><span class="line">data &quot;azurerm_public_ip&quot; &quot;publicip&quot; &#123;</span><br><span class="line">  name                &#x3D; azurerm_public_ip.publicip.name</span><br><span class="line">  resource_group_name &#x3D; azurerm_public_ip.publicip.resource_group_name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Create network interface</span><br><span class="line"># 定义一个网卡</span><br><span class="line">resource &quot;azurerm_network_interface&quot; &quot;nic&quot; &#123;</span><br><span class="line">  name                      &#x3D; &quot;$&#123;var.prefix&#125;-NIC&quot;</span><br><span class="line">  location                  &#x3D; var.location</span><br><span class="line">  resource_group_name       &#x3D; var.resource_group</span><br><span class="line"></span><br><span class="line">  ip_configuration &#123; # 网卡配置参数</span><br><span class="line">    name                          &#x3D; &quot;$&#123;var.prefix&#125;-NIC-Confg&quot;</span><br><span class="line">    subnet_id                     &#x3D; var.subnet_id # 所属子网</span><br><span class="line">    private_ip_address_allocation &#x3D; &quot;dynamic&quot; # 在子网中，被分配IP的类型，这里是动态的</span><br><span class="line">    public_ip_address_id          &#x3D; azurerm_public_ip.publicip.id # 关联的公网IP，也就是前文创建的Public IP资源</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># output.tf</span><br><span class="line"># 为顶层模块的虚拟机提供网卡支持，输出ID即可</span><br><span class="line">output &quot;nic_id&quot; &#123;</span><br><span class="line">    value &#x3D; azurerm_network_interface.nic.id</span><br><span class="line">&#125;</span><br><span class="line"># 为顶层模块提供自动构建的公网IP，用于顶层模块的输出显示！</span><br><span class="line">output &quot;public_ip_address&quot; &#123;</span><br><span class="line">    value &#x3D; data.azurerm_public_ip.publicip.ip_address</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有好的建议和想法？联系我吧"><a href="#有好的建议和想法？联系我吧" class="headerlink" title="有好的建议和想法？联系我吧"></a>有好的建议和想法？联系我吧</h2><p>本项目的官方文档会持续更新，如果有什么建议可以直接邮件给作者<code>prexer@163.com</code>。</p>]]></content>
      
      
      <categories>
          
          <category> terraform </category>
          
          <category> azure-cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> azure </tag>
            
            <tag> terraform </tag>
            
            <tag> cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你想通过本地构建CA来颁发证书么？</title>
      <link href="2020/10/30/ca-certificate-authentication-md/"/>
      <url>2020/10/30/ca-certificate-authentication-md/</url>
      
        <content type="html"><![CDATA[<div class="note light flat"><p>进来看看我们如何在本地构建CA并颁发证书吧！</p></div><a id="more"></a><p>放在前头，本文并不是深入讲解CA鉴权的博文，而是就具体的使用而整理的一篇精简短文。</p><p>没错，写这篇文章的时候确实是战战兢兢，生怕露出马脚，毕竟笔者不是从事安全专业的。</p><p>好在本文的所有内容均有实践验证，这让笔者在操刀的时候踏实不少。</p><p>书归正传，看看如何使用自建CA完成证书的签署和颁发吧。</p><h2 id="可复现的系统环境"><a href="#可复现的系统环境" class="headerlink" title="可复现的系统环境"></a>可复现的系统环境</h2><p>操作系统套件版本信息：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prexer $ cat /proc/version</span><br><span class="line">Linux version 4.18.0-25-generic (buildd@lcy01-amd64-025) (gcc version 8.3.0 (Ubuntu 8.3.0-6ubuntu1~18.10.1)) #26-Ubuntu SMP Mon Jun 24 09:32:08 UTC 2019</span><br></pre></td></tr></table></figure><p>openssl工具版本信息：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prexer $ openssl version</span><br><span class="line">OpenSSL 1.1.1  11 Sep 2018</span><br></pre></td></tr></table></figure><p>python3版本信息：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prexer $ python3 --version</span><br><span class="line">Python 3.8.5</span><br></pre></td></tr></table></figure><p>docker版本信息：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prexer $ docker --version</span><br><span class="line">Docker version 18.09.7, build 2d0083d</span><br></pre></td></tr></table></figure><p>这里只是笔者的环境，并不是说你必须一样才能通过，只不过在这个版本上，笔者是经过充分验证的。</p><h2 id="CA证书涉及的对象有哪些？"><a href="#CA证书涉及的对象有哪些？" class="headerlink" title="CA证书涉及的对象有哪些？"></a>CA证书涉及的对象有哪些？</h2><p>一一列举：</p><ul><li>假冒的授权中心，其实就是一个私钥/公钥对<ul><li>ca-key.pem &lt; 私钥</li><li>ca.pem &lt; 公钥</li></ul></li><li>服务端证书私钥/公钥对，这些还不够，如果要颁发证书，必须要有签名请求文件才可以<ul><li>server-key.pem &lt; 私钥</li><li>server.csr</li><li>ca.srl &lt; 服务端与客户端通用的</li><li>server-cert.pem &lt; 公钥</li></ul></li><li>类似的，客户端证书也是同样的一对密钥，请求文件当然不能少，只不过细微的部分和服务端配置不同，详见下文<ul><li>client-key.pem &lt; 私钥</li><li>client.csr</li><li>ca.srl</li><li>extfile.conf &lt; 扩展了SSL属性的文件</li><li>client-cert.pem &lt; 公钥</li></ul></li></ul><p>后续生成文件树的概览：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">prexer $ tree CA/ CA_demo/</span><br><span class="line">CA/</span><br><span class="line">├── ca-key.pem</span><br><span class="line">├── ca.pem</span><br><span class="line">├── ca.srl</span><br><span class="line">├── client-cert.pem</span><br><span class="line">├── client.csr</span><br><span class="line">├── client-key.pem</span><br><span class="line">├── client.p12</span><br><span class="line">├── extfile.conf</span><br><span class="line">├── server-cert.pem</span><br><span class="line">├── server.csr</span><br><span class="line">└── server-key.pem</span><br><span class="line">CA_demo/</span><br><span class="line">├── https-home</span><br><span class="line">│   └── index.html</span><br><span class="line">└── nginx-conf</span><br><span class="line">    └── default.conf</span><br><span class="line"></span><br><span class="line">2 directories, 13 files</span><br></pre></td></tr></table></figure><h2 id="建立一个证书授权中心玩玩"><a href="#建立一个证书授权中心玩玩" class="headerlink" title="建立一个证书授权中心玩玩"></a>建立一个证书授权中心玩玩</h2><p>证书授权中心当然不能随便建立，这里说的建立是一个抽象层面的说法，本质上我们使用openssl工具建立一个本地的虚假证书机构。</p><p>虽然它颁发的不是官方的授权证书，但对于实际的应用来说依旧有用。</p><p>后文证书的私钥/公钥均采用<code>2048字节</code>，如果有需要可以提升。</p><p>简单一句完成建立：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">prexer $ sudo openssl genrsa -des3 -out ca-key.pem</span><br><span class="line">Generating RSA private key, 2048 bit long modulus (2 primes)</span><br><span class="line">...................................................................+++++</span><br><span class="line">......................+++++</span><br><span class="line">e is 65537 (0x010001)</span><br><span class="line">Enter pass phrase for ca-key.pem:</span><br><span class="line">Verifying - Enter pass phrase for ca-key.pem:</span><br></pre></td></tr></table></figure><p>这里的<code>ca-key.pem</code>就是你本地CA授权机构的密钥，你就当他是授权机构。<br>执行的时候需要你输入密码，这个密码要记住，不仅后续的指令还要依赖它，没准以后其他情况也要用到哦。</p><h2 id="颁发认证机构的证书"><a href="#颁发认证机构的证书" class="headerlink" title="颁发认证机构的证书"></a>颁发认证机构的证书</h2><p>使用前文创建的证书机构密钥来建立一个代表机构的证书，当然也很简单：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">prexer $ sudo openssl req -new -x509 -days 365 -key ca-key.pem -out ca.pem</span><br><span class="line">Enter pass phrase for ca-key.pem:</span><br><span class="line">Can&#x27;t load /home/wei/.rnd into RNG</span><br><span class="line">140197562365120:error:2406F079:random number generator:RAND_load_file:Cannot open file:../crypto/rand/randfile.c:88:Filename=/home/wei/.rnd</span><br><span class="line">You are about to be asked to enter information that will be incorporated</span><br><span class="line">into your certificate request.</span><br><span class="line">What you are about to enter is what is called a Distinguished Name or a DN.</span><br><span class="line">There are quite a few fields but you can leave some blank</span><br><span class="line">For some fields there will be a default value,</span><br><span class="line">If you enter &#x27;.&#x27;, the field will be left blank.</span><br><span class="line">-----</span><br><span class="line">Country Name (2 letter code) [AU]:</span><br><span class="line">State or Province Name (full name) [Some-State]:</span><br><span class="line">Locality Name (eg, city) []:</span><br><span class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:</span><br><span class="line">Organizational Unit Name (eg, section) []:</span><br><span class="line">Common Name (e.g. server FQDN or YOUR name) []:prexer.gitee.io</span><br><span class="line">Email Address []:</span><br></pre></td></tr></table></figure><p>相关参数请自行到搜索引擎查询，讲解的文章成片飘落…<br>这里还要说明两点：</p><ol><li>在输入FQDN，也就是Common Name的时候给一个服务的名字，正式的时候需要添加详细的信息，这里是一个演示，所以只是例子。</li><li>指令执行的时候需要输入ca-key.pem的密码，你懂的。</li></ol><h2 id="创建用于服务端的证书签名请求和密钥"><a href="#创建用于服务端的证书签名请求和密钥" class="headerlink" title="创建用于服务端的证书签名请求和密钥"></a>创建用于服务端的证书签名请求和密钥</h2><p>在正式颁发指定服务端证书的时候，需要一个证书签名请求，而这个证书的签名请求还需要你为服务器生成一个服务端的密钥文件。</p><p>那么，我们先生成一个服务端的密钥文件：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">prexer $ sudo openssl genrsa -des3 -out server-key.pem</span><br><span class="line">Generating RSA private key, 2048 bit long modulus (2 primes)</span><br><span class="line">.........+++++</span><br><span class="line">.............................................+++++</span><br><span class="line">e is 65537 (0x010001)</span><br><span class="line">Enter pass phrase for server-key.pem:</span><br><span class="line">Verifying - Enter pass phrase for server-key.pem:</span><br></pre></td></tr></table></figure><p>没错，他和生成虚假认证机构的密钥是相似的，过程中需要你为它也设置一个密码，这个密码后续我们会删除，毕竟大部分应用场景都不需要密码完成认证。</p><p>接下来，用上面的服务器密钥来生成一个证书签名请求：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">prexer $ sudo openssl req -new -key server-key.pem -out server.csr</span><br><span class="line">Enter pass phrase for server-key.pem:</span><br><span class="line">Can&#x27;t load /home/wei/.rnd into RNG</span><br><span class="line">139737719624896:error:2406F079:random number generator:RAND_load_file:Cannot open file:../crypto/rand/randfile.c:88:Filename=/home/wei/.rnd</span><br><span class="line">You are about to be asked to enter information that will be incorporated</span><br><span class="line">into your certificate request.</span><br><span class="line">What you are about to enter is what is called a Distinguished Name or a DN.</span><br><span class="line">There are quite a few fields but you can leave some blank</span><br><span class="line">For some fields there will be a default value,</span><br><span class="line">If you enter &#x27;.&#x27;, the field will be left blank.</span><br><span class="line">-----</span><br><span class="line">Country Name (2 letter code) [AU]:</span><br><span class="line">State or Province Name (full name) [Some-State]:</span><br><span class="line">Locality Name (eg, city) []:</span><br><span class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:</span><br><span class="line">Organizational Unit Name (eg, section) []:</span><br><span class="line">Common Name (e.g. server FQDN or YOUR name) []:*</span><br><span class="line">Email Address []:</span><br><span class="line"></span><br><span class="line">Please enter the following &#x27;extra&#x27; attributes</span><br><span class="line">to be sent with your certificate request</span><br><span class="line">A challenge password []:</span><br><span class="line">An optional company name []:</span><br></pre></td></tr></table></figure><p>这里除了要输入密码，还要重点注意<code>FQDN</code>这个选项，这里设置为<code>*</code>是表示允许该证书在任意的一台服务器上都可以使用，当然，你也可以按照你的需求指定一个有效的服务器，如：prexer.example.org</p><h2 id="正式生成服务端的证书"><a href="#正式生成服务端的证书" class="headerlink" title="正式生成服务端的证书"></a>正式生成服务端的证书</h2><p>有了请求，向认证机构申请证书还是比较简单的，不过在请求前，要先生成一个<code>srl</code>文件：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prexer $ echo 01 &gt; $PWD/ca.srl</span><br></pre></td></tr></table></figure><p>开始颁发证书吧：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prexer $ sudo openssl x509 -req -days 365 -in server.csr -CA ca.pem -CAkey ca-key.pem -out server-cert.pem</span><br><span class="line">Signature ok</span><br><span class="line">subject=C = AU, ST = Some-State, O = Internet Widgits Pty Ltd, CN = *</span><br><span class="line">Getting CA Private Key</span><br><span class="line">Enter pass phrase for ca-key.pem:</span><br></pre></td></tr></table></figure><p>密码什么的相信你已经熟练的使用了，接下来完成一个实用的步骤，移除服务端的密钥密码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prexer $ sudo openssl rsa -in server-key.pem -out server-key.pem</span><br><span class="line">Enter pass phrase for server-key.pem:</span><br><span class="line">writing RSA key</span><br></pre></td></tr></table></figure><p>如果你还是没安全感，那就让文件的权限跟窄一些：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 0600 *.pem</span><br></pre></td></tr></table></figure><p>这一步骤你可以根据需求执行，到现在我们拥有的文件试图应该是:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">prexer $ ls -l</span><br><span class="line">total 24</span><br><span class="line">-rw------- 1 root root 1743 10月 30 23:06 ca-key.pem</span><br><span class="line">-rw------- 1 root root 1318 10月 30 23:12 ca.pem</span><br><span class="line">-rw-r--r-- 1 wei  wei     3 10月 30 23:32 ca.srl</span><br><span class="line">-rw------- 1 root root 1151 10月 30 23:32 server-cert.pem</span><br><span class="line">-rw-r--r-- 1 root root  972 10月 30 23:24 server.csr</span><br><span class="line">-rw------- 1 root root 1675 10月 30 23:36 server-key.pem</span><br></pre></td></tr></table></figure><h2 id="创建客户端的密钥和证书"><a href="#创建客户端的密钥和证书" class="headerlink" title="创建客户端的密钥和证书"></a>创建客户端的密钥和证书</h2><p>操作方法和服务器端相似，先生成客户端密钥：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">prexer $ sudo openssl genrsa -des3 -out client-key.pem</span><br><span class="line">Generating RSA private key, 2048 bit long modulus (2 primes)</span><br><span class="line">.............+++++</span><br><span class="line">...................................+++++</span><br><span class="line">e is 65537 (0x010001)</span><br><span class="line">Enter pass phrase for client-key.pem:</span><br><span class="line">Verifying - Enter pass phrase for client-key.pem:</span><br></pre></td></tr></table></figure><p>这个阶段同样要设置一个临时的密码，后续会删除。</p><p>接下来创建一个客户端证书签名请求，和前文一样，是一个CSR文件：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">prexer $ sudo openssl req -new -key client-key.pem -out client.csr</span><br><span class="line">Enter pass phrase for client-key.pem:</span><br><span class="line">Can&#x27;t load /home/wei/.rnd into RNG</span><br><span class="line">140471898436800:error:2406F079:random number generator:RAND_load_file:Cannot open file:../crypto/rand/randfile.c:88:Filename=/home/wei/.rnd</span><br><span class="line">You are about to be asked to enter information that will be incorporated</span><br><span class="line">into your certificate request.</span><br><span class="line">What you are about to enter is what is called a Distinguished Name or a DN.</span><br><span class="line">There are quite a few fields but you can leave some blank</span><br><span class="line">For some fields there will be a default value,</span><br><span class="line">If you enter &#x27;.&#x27;, the field will be left blank.</span><br><span class="line">-----</span><br><span class="line">Country Name (2 letter code) [AU]:</span><br><span class="line">State or Province Name (full name) [Some-State]:</span><br><span class="line">Locality Name (eg, city) []:</span><br><span class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:</span><br><span class="line">Organizational Unit Name (eg, section) []:</span><br><span class="line">Common Name (e.g. server FQDN or YOUR name) []:</span><br><span class="line">Email Address []:</span><br><span class="line"></span><br><span class="line">Please enter the following &#x27;extra&#x27; attributes</span><br><span class="line">to be sent with your certificate request</span><br><span class="line">A challenge password []:</span><br><span class="line">An optional company name []:</span><br></pre></td></tr></table></figure><p>这里除了密码没有什么要注意的地方，也是客户端与服务端的第一点差别。</p><p>第二点差别是，有时候需要在使用客户端的时候添加SSL的扩展属性，也就类似TSL/SSL这样的需求。<br>其实也很好办，这里给出一个简单的样例，先生成一个SSL扩展文件：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prexer $ echo extendedKeyUsage = clientAuth &gt; extfile.conf</span><br></pre></td></tr></table></figure><p>来吧，都准备好了，那就进行签名授书喽：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prexer $ sudo openssl x509 -req -days 365 -in client.csr -CA ca.pem -CAkey ca-key.pem -out client-cert.pem -extfile extfile.conf</span><br><span class="line">Signature ok</span><br><span class="line">subject=C = AU, ST = Some-State, O = Internet Widgits Pty Ltd</span><br><span class="line">Getting CA Private Key</span><br><span class="line">Enter pass phrase for ca-key.pem:</span><br></pre></td></tr></table></figure><p>输入认证机构密钥密码后，客户端的证书也就授权完成了，一鼓作气，让我们把客户端密钥的密码删掉吧：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prexer $ sudo openssl rsa -in client-key.pem -out client-key.pem</span><br><span class="line">Enter pass phrase for client-key.pem:</span><br><span class="line">writing RSA key</span><br></pre></td></tr></table></figure><p>好了，到了这里所有的内容都已经准备齐全了，他们应该是这样的：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">prexer $ ls -l</span><br><span class="line">total 40</span><br><span class="line">-rw------- 1 root root 1743 10月 30 23:06 ca-key.pem</span><br><span class="line">-rw------- 1 root root 1318 10月 30 23:12 ca.pem</span><br><span class="line">-rw-r--r-- 1 wei  wei     3 10月 30 23:53 ca.srl</span><br><span class="line">-rw-r--r-- 1 root root 1176 10月 30 23:53 client-cert.pem</span><br><span class="line">-rw-r--r-- 1 root root  956 10月 30 23:46 client.csr</span><br><span class="line">-rw------- 1 root root 1679 10月 30 23:56 client-key.pem</span><br><span class="line">-rw-r--r-- 1 wei  wei    30 10月 30 23:51 extfile.conf</span><br><span class="line">-rw------- 1 root root 1151 10月 30 23:32 server-cert.pem</span><br><span class="line">-rw-r--r-- 1 root root  972 10月 30 23:24 server.csr</span><br><span class="line">-rw------- 1 root root 1675 10月 30 23:36 server-key.pem</span><br></pre></td></tr></table></figure><p>那么接下来的部分我们谈谈验证，毕竟你有了这些东东还要用不是？</p><h2 id="如何验证授权的证书？"><a href="#如何验证授权的证书？" class="headerlink" title="如何验证授权的证书？"></a>如何验证授权的证书？</h2><p>现在，我们已经有了服务端和客户端的双向证书，那么就用下面的案例来验证：</p><ul><li>使用Nginx搭建一个反向代理服务器，在配置文件中使用TSL认证，使用授权的服务端证书，当然这部分要以来https/http协议来完成</li><li>在访问服务器的客户端，不安装授权的客户端证书来问指定服务器</li><li>在访问服务器的客户端，安装授权的客户端证书，然后访问指定服务器</li></ul><h3 id="搭建一个最简单的http服务器"><a href="#搭建一个最简单的http服务器" class="headerlink" title="搭建一个最简单的http服务器"></a>搭建一个最简单的http服务器</h3><p>利用python的内置模块搭建http服务器是一件很简单的事情，不过它是一个简易的http服务器，用来做验证和开发。</p><p>我们创建一个目录，用来存放http服务的主页内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prexer $ mkdir -p $PWD/CA_demo/http-home</span><br></pre></td></tr></table></figure><p>然后写一个简单的索引文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">prexer $ cat &gt; $PWD/CA_demo/http-home/index.html &lt;&lt;EOF</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h3&gt;Python SimpleHTTPServer&lt;/h3&gt;</span><br><span class="line">    &lt;p style=&quot;margin-left: 30px; color: rebeccapurple&quot;&gt;Python 3 Web Server&lt;/p&gt; </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>最后只要到<code>http-home</code>目录启动python内置的http服务即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prexer $ (cd $PWD/CA_demo/http-home/ &amp;&amp; python3 -m http.server 8008 &amp;)</span><br></pre></td></tr></table></figure><p>这里我们绑定了8008端口，后续在配置nginx会重定向到它，看到这里的括号了么，没错它是防止你的操作对<code>父SHELL</code>产生影响而已。</p><p>为了模拟一个有用的设计，我们将本机的地址映射为想要的主机名，后续都用<code>prexer.home</code>来完成<code>localhost</code>或<code>127.0.0.1</code>的映射。<br>其实还可以搭建一个DNS服务来完成这件事，其实也很简单，本站已有相关的文章讲解DNS服务其的内网搭建，请使用本站搜索引擎来翻阅吧。</p><p>完成映射：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prexer $ sudo echo 127.0.0.1 prexer.home &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure><p>现在你访问<code>http://prexer.home:8008</code>的界面应该是这样的(请保证你的8008端口没有被占用)：<br><img src="/images/blog-images/ca_http_index_show.png" alt="理想的显示结果"></p><h3 id="构建一个Ngix反向代理服务"><a href="#构建一个Ngix反向代理服务" class="headerlink" title="构建一个Ngix反向代理服务"></a>构建一个Ngix反向代理服务</h3><p>使用docker构建一Nginx服务简直太简单了，如何安装docker请参考本站的其他文章，依旧直接使用本站的搜索引擎即可。</p><p>接下来默认你已经拥有了docker环境，来一起搭建一个Nginx。</p><p>不过在搭建之前还有一些要准备的工作，其实也很容易，就是一个nginx的配置文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">prexer $ mkdir -p $PWD/CA_demo/nginx-conf</span><br><span class="line">prexer $ cat &gt; $PWD/CA_demo/nginx-conf/default.conf &lt;&lt;EOF</span><br><span class="line">server &#123;</span><br><span class="line">    listen      8000;</span><br><span class="line">    server_name prexer.home;</span><br><span class="line"></span><br><span class="line">    listen   443 ssl;</span><br><span class="line"></span><br><span class="line">    ssl_certificate             /etc/nginx/CA/server-cert.pem;</span><br><span class="line">    ssl_certificate_key         /etc/nginx/CA/server-key.pem;</span><br><span class="line">    ssl_client_certificate      /etc/nginx/CA/ca.pem;</span><br><span class="line">    ssl_verify_client           on;</span><br><span class="line"></span><br><span class="line">    ssl_session_cache           shared:SSL:1m;</span><br><span class="line">    ssl_session_timeout         5m;</span><br><span class="line">    ssl_protocols               SSLv2 SSLv3 TLSv1.2;</span><br><span class="line">    ssl_ciphers                 HIGH:!aNULL:!MD5;</span><br><span class="line">    ssl_prefer_server_ciphers   on;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://localhost:8008/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>好了，开始构建nginx服务容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prexer $ docker run -t --name ca_nginx -d \</span><br><span class="line">--net=host \</span><br><span class="line">--volume `pwd`/CA:/etc/nginx/CA \</span><br><span class="line">--volume `pwd`/CA_demo/nginx-conf/default.conf:/etc/nginx/conf.d/default.conf \</span><br><span class="line">--privileged=true \</span><br><span class="line">nginx:latest</span><br></pre></td></tr></table></figure><p>到了这里你的目录结构应该是这样才对：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">prexer $ tree CA_demo/ CA/</span><br><span class="line">CA_demo/</span><br><span class="line">├── https-home</span><br><span class="line">│   └── index.html</span><br><span class="line">└── nginx-conf</span><br><span class="line">    └── default.conf</span><br><span class="line">CA/</span><br><span class="line">├── ca-key.pem</span><br><span class="line">├── ca.pem</span><br><span class="line">├── ca.srl</span><br><span class="line">├── client-cert.pem</span><br><span class="line">├── client.csr</span><br><span class="line">├── client-key.pem</span><br><span class="line">├── extfile.conf</span><br><span class="line">├── server-cert.pem</span><br><span class="line">├── server.csr</span><br><span class="line">└── server-key.pem</span><br><span class="line"></span><br><span class="line">2 directories, 12 files</span><br></pre></td></tr></table></figure><p>查看docker容器的输出可以这样：<code>docker logs -f ca_nginx</code></p><p>到这里nginx也搭建完成了，下面来验证。</p><h3 id="通过浏览器来验证自建证书的有效性"><a href="#通过浏览器来验证自建证书的有效性" class="headerlink" title="通过浏览器来验证自建证书的有效性"></a>通过浏览器来验证自建证书的有效性</h3><p>首先，浏览器没有安装证书的时候，应该得到这样的结果：<br><img src="/images/blog-images/ca_no_cert.png" alt="没有证书的时候"></p><p>很遗憾，浏览器并不能直接使用刚才我们制定的证书格式，它需要用一个转换后的格式，这里我们生成<code>.p12</code>文件，至于格式的知识请自行索引。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prexer $ sudo openssl pkcs12 -export -in client-cert.pem -inkey client-key.pem -out client.p12 -name &quot;iot&quot;</span><br></pre></td></tr></table></figure><p>这里转换成另一种格式的证书时，需要输入密码，请记住它，后续要在浏览器中使用！</p><p>好了现在我们有了<code>client.p12</code>文件，浏览器可以很好的支持它，你肯定已经记住了它的生成位置，现在通过浏览器添加证书：<br><img src="/images/blog-images/ca_import_cert_to_firefox.png" alt="导入证书步骤"></p><p>添加完成后再次访问<code>https://prexer.home</code>，应该是这样：<br><img src="/images/blog-images/ca_cert_imported.png" alt="添加证书后"></p><p>到了这里所有相关证书的生成和验证流程就讲解完成了，真心希望对你有帮助呢 ^_^</p>]]></content>
      
      
      <categories>
          
          <category> CA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CA </tag>
            
            <tag> 证书 </tag>
            
            <tag> 鉴权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在内网快速利用docker搭建DNS服务器</title>
      <link href="2020/10/29/docker/internal_dns_server_setup/"/>
      <url>2020/10/29/docker/internal_dns_server_setup/</url>
      
        <content type="html"><![CDATA[<div class="note light flat"><p>如果你还犯愁，如何在内网搭建DNS服务器，那么请看看这里吧。</p></div><a id="more"></a><h2 id="当前主机是否已经启用53端口？"><a href="#当前主机是否已经启用53端口？" class="headerlink" title="当前主机是否已经启用53端口？"></a>当前主机是否已经启用53端口？</h2><p>如果你不清楚53端口的功能，请查看下<code>/etc/services</code>文件，它会告诉你答案。</p><p>为了顺利进行下一步，需要确保你的机器上没有开启53端口，也就是说你的主机不是一个DNS Server。</p><p>如何确定呢？当然要使用<code>netstat命令</code>来查看端口，当然配合<code>lsof命令</code>也许会更明确。</p><p>比如笔者本机就是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">prexer $ netstat -ntulp | grep 53</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      -</span><br><span class="line">udp        0      0 127.0.0.53:53           0.0.0.0:*                           -</span><br><span class="line">udp        0      0 0.0.0.0:5353            0.0.0.0:*                           -</span><br><span class="line">udp6       0      0 :::5353                 :::*                                -</span><br><span class="line"></span><br><span class="line">prexer $ sudo lsof -i:53</span><br><span class="line">COMMAND   PID            USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">systemd-r 778 systemd-resolve   12u  IPv4  20918      0t0  UDP localhost:domain</span><br><span class="line">systemd-r 778 systemd-resolve   13u  IPv4  20919      0t0  TCP localhost:domain (LISTEN)</span><br></pre></td></tr></table></figure><p>如果找到了端口占用，只要关闭指定的程序即可，简单来说就是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prexer $ sudo systemctl stop systemd-resolve</span><br><span class="line"># 或者</span><br><span class="line">prexer $ sudo kill your_pid</span><br></pre></td></tr></table></figure><h2 id="用什么来构建DNS服务器呢？"><a href="#用什么来构建DNS服务器呢？" class="headerlink" title="用什么来构建DNS服务器呢？"></a>用什么来构建DNS服务器呢？</h2><p>当然是大名鼎鼎的<code>DNSmasq</code>了，如果你不了解，您这边请: <a href="http://www.thekelleys.org.uk/dnsmasq/doc.html%E3%80%82">http://www.thekelleys.org.uk/dnsmasq/doc.html。</a></p><p>这个项目是有命令行支持的，参考官网也可以很容易构建出来，不过本文打算使用更简单的docker容器来完成这件事。</p><p>说到这里，请注意，本文并没有直接使用官方提供的docker镜像，而是使用了另一个拥有web支持的docker镜像。</p><ul><li>官方镜像在<a href="https://hub.docker.com/r/andyshinn/dnsmasq/">这里</a></li><li>有web支持的镜像在<a href="https://github.com/jpillora/docker-dnsmasq">这里</a></li></ul><h2 id="构建一个符合你胃口的DNSmasq的配置文件"><a href="#构建一个符合你胃口的DNSmasq的配置文件" class="headerlink" title="构建一个符合你胃口的DNSmasq的配置文件"></a>构建一个符合你胃口的DNSmasq的配置文件</h2><p>对于配置docker镜像而言，配置文件肯定是逃不了的，你可以先看看<a href="http://oss.segetech.com/intra/srv/dnsmasq.conf">官方的配置文档</a>，了解有什么后，再动手也不迟。</p><p>这里我们介绍一个通用且简单的配置，当你学完后可以自己进行修改，多开心。</p><p>配置文件及解释如下：(将这个文件保存为：dnsmasq.conf文件，存储在你当前的工作目录或者任意可指定的目录即可)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># filename: dnsmasq.conf</span><br><span class="line"></span><br><span class="line"># 需要存储log，后续再命令行中指定log的限制大小</span><br><span class="line">log-queries</span><br><span class="line"></span><br><span class="line"># 指定一个自定义的解析文件，它可以保证你不用修改原始的配置文件&#x2F;etc&#x2F;resolv.conf</span><br><span class="line">resolv-file&#x3D;&#x2F;tmp&#x2F;resolv.conf</span><br><span class="line"></span><br><span class="line"># 一个测试的名字，IP地址是内部网络的另一台主机，通过这个名字来完成后续的验证</span><br><span class="line">address&#x3D;&#x2F;hello.remote&#x2F;10.22.52.229</span><br><span class="line"></span><br><span class="line"># upstream nameserver，也就是找不到靠上游的道理</span><br><span class="line"># server&#x3D;&#x2F;localnet&#x2F;127.0.0.1 # 不加也可以，添加非公开的内网DNS，就像联机打游戏一样 </span><br><span class="line">server&#x3D;10.22.0.1</span><br><span class="line">server&#x3D;10.22.0.2</span><br></pre></td></tr></table></figure><p>复制一份解析文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prexer $ sudo cp /etc/resolv.conf /tmp/resolv.conf</span><br></pre></td></tr></table></figure><p>到了这里，基本的配置就算完成了，很简单吧，之后我们开始启动DNSmasq容器。</p><h2 id="开始构建激动人心的docker容器"><a href="#开始构建激动人心的docker容器" class="headerlink" title="开始构建激动人心的docker容器"></a>开始构建激动人心的docker容器</h2><p>众所周知，容器的使用是廉价的，所以你几乎不用知道细节就可以搭建一个完美的沙盒环境（一点不知道也不行哈…)。按照官方文档的指示，你当然可以修改docker启动的参数，然后鼓捣鼓捣自己的配置，反正玩不坏，尽情尝试。不过为了教学，请看看我的例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -d\</span><br><span class="line">    --name dnsmasq \</span><br><span class="line">    --rm \</span><br><span class="line">    -p 53:53/udp \</span><br><span class="line">    -p 53:53/tcp \</span><br><span class="line">    -p 8080:8080 \</span><br><span class="line">    -v `pwd`/dnsmasq.conf:/etc/dnsmasq.conf \</span><br><span class="line">    --log-opt &quot;max-size=100m&quot; \</span><br><span class="line">    -e &quot;HTTP_USER=root&quot; \</span><br><span class="line">    -e &quot;HTTP_PASS=root&quot; \</span><br><span class="line">    jpillora/dnsmasq</span><br></pre></td></tr></table></figure><p>一些简单的参数解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -d\ # 以守护进程的方式运行容器</span><br><span class="line">    --name dnsmasq \ # 容器的名字</span><br><span class="line">    --rm \ # 用完后删除，即你stop的时候就会删除哦</span><br><span class="line">    -p 53:53&#x2F;udp \ # 暴露容器的53端口和宿主机关联，udp&#x2F;tcp协议如果你不懂，简单百科一下</span><br><span class="line">    -p 53:53&#x2F;tcp \</span><br><span class="line">    -p 8080:8080 \ # 暴露容器的web端口，便于后续再网页上查看和配置</span><br><span class="line">    -v &#96;pwd&#96;&#x2F;dnsmasq.conf:&#x2F;etc&#x2F;dnsmasq.conf \ # 重点，配置文件的关联，这个逻辑卷的知识你可以自行科普</span><br><span class="line">    --log-opt &quot;max-size&#x3D;100m&quot; \ # 限制输出的log文件的大小，很简单是吧，呼应前文</span><br><span class="line">    -e &quot;HTTP_USER&#x3D;root&quot; \ # 登录web的用户名和密码</span><br><span class="line">    -e &quot;HTTP_PASS&#x3D;root&quot; \</span><br><span class="line">    jpillora&#x2F;dnsmasq # 包含web的基础dnsmasq镜像</span><br></pre></td></tr></table></figure><p>查看启动状态，只是一些基础的docker指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> &gt; docker ps -a |grep dnsmasq <span class="comment"># 看容器的启动状态</span></span></span><br><span class="line">prexer $ docker ps -a|grep dnsmasq</span><br><span class="line">6d75bfc34244        jpillora/dnsmasq                       &quot;webproc --config /e…&quot;   18 seconds ago      Up 17 seconds       0.0.0.0:53-&gt;53/tcp, 0.0.0.0:8080-&gt;8080/tcp, 0.0.0.0:53-&gt;53/udp   dnsmasq</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> &gt; docker logs -f dnsmasq <span class="comment"># 看容器的标准输出log</span></span></span><br><span class="line">prexer $ docker logs -f dnsmasq</span><br><span class="line">[webproc] 2020/10/30 00:37:30 loaded config files changes from disk</span><br><span class="line">[webproc] 2020/10/30 00:37:30 agent listening on http://0.0.0.0:8080...</span><br><span class="line">dnsmasq: started, version 2.80 cachesize 150</span><br><span class="line">dnsmasq: compile time options: IPv6 GNU-getopt no-DBus no-i18n no-IDN DHCP DHCPv6 no-Lua TFTP no-conntrack ipset auth no-DNSSEC loop-detect inotify dumpfile</span><br><span class="line">dnsmasq: using nameserver 10.22.0.2#53</span><br><span class="line">dnsmasq: using nameserver 10.22.0.1#53</span><br><span class="line">dnsmasq: read /etc/hosts - 7 addresses</span><br></pre></td></tr></table></figure><p>至于是否启动成功，看看输出结果，对比对比就成了。</p><h2 id="来吧，一起可视化查看与验证"><a href="#来吧，一起可视化查看与验证" class="headerlink" title="来吧，一起可视化查看与验证"></a>来吧，一起可视化查看与验证</h2><p>从浏览器登录你已经配置的主机，方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在浏览器中输入：http:&#x2F;&#x2F;localhost:8080 或者 http:&#x2F;&#x2F;remote_ip_address:8080</span><br></pre></td></tr></table></figure><p>这样就能到达登录界面，用户名和密码是之前命令行参数中配置的，请自行填写，效果如下：</p><p><img src="/images/blog-images/dns_web_show.png" alt="login web"></p><p>登录后的界面如下：</p><p><img src="/images/blog-images/dns_web_display.png" alt="display web"></p><p>在验证之前还需要一点知识要梳理：</p><p>首先，之前复制的DNS解析文件<code>/tmp/resolv.conf</code>是配置的DNSmasq解析的上游服务文件，具体请看下面的解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Change this line if you want dns to get its upstream servers from</span><br><span class="line"># somewhere other that &#x2F;etc&#x2F;resolv.conf</span><br><span class="line">#resolv-file&#x3D;</span><br></pre></td></tr></table></figure><p>很多同学在里面配置了<code>nameserver 127.0.0.1</code>本地的地址，想要使用本地的docker DNS服务，其实还不行，需要你真正配置本机的DNS解析文件才可以，也就是修改<code>/etc/resolv.conf</code>添加如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameserver 127.0.0.1</span><br></pre></td></tr></table></figure><p>到这里基本上可以进行下一步了。</p><p>那么我们验证一下配置的结果吧：</p><p>首先用你们最熟悉的<code>ping</code>指令，走个ICMP协议看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">prexer $ ping hello.remote -c 3</span><br><span class="line">PING hello.remote (10.22.52.229) 56(84) bytes of data.</span><br><span class="line">64 bytes from CNSHZ-ED-SVR097.sierrawireless.local (10.22.52.229): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.190 ms</span><br><span class="line">64 bytes from CNSHZ-ED-SVR097.sierrawireless.local (10.22.52.229): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.257 ms</span><br><span class="line">64 bytes from CNSHZ-ED-SVR097.sierrawireless.local (10.22.52.229): icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;0.230 ms</span><br><span class="line"></span><br><span class="line">--- hello.remote ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 1998ms</span><br><span class="line">rtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 0.190&#x2F;0.225&#x2F;0.257&#x2F;0.032 ms</span><br></pre></td></tr></table></figure><p>在来看看主机的IP地址映射关系，当然要用<code>host</code>指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prexer $ host hello.remote</span><br><span class="line">hello.remote has address 10.22.52.229</span><br></pre></td></tr></table></figure><p>其他的协议不用一一验证了，应为这是标准的端口，也是通用的tcp/udp协议簇，如果你还好奇，可以验证<code>ssh</code>或者<code>dig</code>之类的指令玩玩。</p><h2 id="内网其他主机如何使用你的DNS服务器？"><a href="#内网其他主机如何使用你的DNS服务器？" class="headerlink" title="内网其他主机如何使用你的DNS服务器？"></a>内网其他主机如何使用你的DNS服务器？</h2><p>本机用当然还不够，要内网其他同事能够使用才行，其实用起来依旧很简单，就是在内网的任意机器上（可达你的主机），修改<code>/etc/resolv.conf</code>文件，添加一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameserver &lt;your_dns_server_ip_address&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;your_dns_server_ip_address&gt;</code>这个替换你的主机IP就可以了。</p><p>赶快用起来！<code>^_^</code></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
          <category> DNS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> dns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐一个加速git仓库下载的方法</title>
      <link href="2020/10/24/base/git_speed_up_downloading/"/>
      <url>2020/10/24/base/git_speed_up_downloading/</url>
      
        <content type="html"><![CDATA[<div class="note light flat"><p>如果访问github限速，那就试试这个方法吧!</p></div><a id="more"></a><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>今时已不同往日，网络资源已经逐渐被管控和限制，就当下的形式而言，外网访问的制约，对于一个程序员来说谈不上好事还是坏事。</p><p>不过，如果你在墙内看不到外面的风景，那确实有点可惜，不管是因为墙太高（就像进击的巨人一样）还是其他原因。</p><p>换个法子，将墙外你感兴趣的风景，借助公家条件，移植到墙内来，这样就可以满足你的欲望，岂不美哉。</p><p>截止到文章编写之日，github对国内用户来说已经限速，下载个几十兆的仓库都要好几十分钟，并且有断开的风险，所以请借助gitee达到你的目的吧。</p><h2 id="如何做？"><a href="#如何做？" class="headerlink" title="如何做？"></a>如何做？</h2><p>很简单，利用码云gitee的同步功能，来同步你在github上感兴趣的仓库，然后利用国内极速的网络来完成clone或者下载。</p><h3 id="定位github上的仓库目标"><a href="#定位github上的仓库目标" class="headerlink" title="定位github上的仓库目标"></a>定位github上的仓库目标</h3><p>比如，你在github上看到中了：<a href="https://github.com/hexojs/hexo-starter">https://github.com/hexojs/hexo-starter</a></p><p>那么，请复制这个URL。</p><h3 id="注册并创建gitee仓库"><a href="#注册并创建gitee仓库" class="headerlink" title="注册并创建gitee仓库"></a>注册并创建gitee仓库</h3><p>登录gitee官网：<a href="https://gitee.com/">https://gitee.com/</a></p><p>注册流程交给你自己，就像其他网站注册一样，比较好玩的是国内的gitee可使用手机号绑定并登陆。</p><p>找到并点击<code>新建仓库</code>，然后拖到最后，点击<code>导入仓库</code>，并填写刚才复制的URL地址。</p><p>gitee会自动帮你填充仓库的信息，当然你也可自己修改感兴趣的部分。</p><p>不过最好记得填写<code>descriptin</code>，也就是<code>描述</code>部分，这样可以让别人知道你仓库的来源，也是一种尊重作者的体现。</p><p>最后点击<code>创建</code>，好了，完成。</p><h3 id="使用gitee"><a href="#使用gitee" class="headerlink" title="使用gitee"></a>使用gitee</h3><p>gitee的用法和github一样，并不特殊，你只需要换一个URL地址。</p><p>从以前的：<br><code>git clone https://github.com/hexojs/hexo-starter.git</code></p><p>到现在的：<br><code>git clone https://gitee.com/prexer/hexo-starter.git</code></p><p>享受极速服务的感觉很不错吧？<code>^_^</code></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> gitee </tag>
            
            <tag> github </tag>
            
            <tag> git加速 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文章编写规范</title>
      <link href="2020/02/20/articles_writing_rules/"/>
      <url>2020/02/20/articles_writing_rules/</url>
      
        <content type="html"><![CDATA[<div class="note light flat"><p>本站文章书写规范参考指南。</p></div><a id="more"></a><p>文章开头类似如下的语法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span></span><br><span class="line"><span class="attr">date:</span></span><br><span class="line"><span class="attr">top_img:</span></span><br><span class="line"><span class="attr">cover:</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>在Hexo中叫做<code>Front-Matter</code>，通过它你可以限定文章的一些行为。</p><p>所以本文重点说明Hexo的<code>Front-Matter</code>和<code>文章书写格式</code></p><h1 id="Front-Matter中必要的信息"><a href="#Front-Matter中必要的信息" class="headerlink" title="Front-Matter中必要的信息"></a>Front-Matter中必要的信息</h1><h2 id="title"><a href="#title" class="headerlink" title="title"></a>title</h2><p>文章标题，内置中文支持</p><h2 id="date"><a href="#date" class="headerlink" title="date"></a>date</h2><p>文章撰写时间</p><h2 id="top-img"><a href="#top-img" class="headerlink" title="top_img"></a>top_img</h2><p>当前文章页面顶部大图，可以使用本地图片的相对路径，也可以为外站链接。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">站内： top_img&#x27;: /images/site/example.jpg   # 对应存放在 /source/images/site/example.jpg</span><br><span class="line">站外： top_img: https://static.zkqiang.cn/example.jpg</span><br></pre></td></tr></table></figure><p><strong>NOTE</strong>: 图片大小建议压缩到 1MB 以内，否则会严重拖慢页面加载</p><h2 id="cover-文章首页缩略图"><a href="#cover-文章首页缩略图" class="headerlink" title="cover - 文章首页缩略图"></a>cover - 文章首页缩略图</h2><p>站点主页中文章索引图片，也就是首页文章的缩略图；依然可以使用本地或者远程图片资源。</p><p>使用<code>Front-Matter</code>形式配置，与<code>top_img</code>配置类似，格式如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cover:</span> <span class="string">/images/somewhere/example.jpg</span></span><br></pre></td></tr></table></figure><h2 id="categories"><a href="#categories" class="headerlink" title="categories"></a>categories</h2><p>文章归档种类，一般认为，<code>categories</code>用来描述文章作者的知识结构树，文章应该明确属于某一个领域，哪怕它已经借鉴了其他领域的知识。<br>分类包含层级关系，一般一个文章属于一个种类，如果使用列表方式存放多个类别，那就会形成<code>类别树</code>，如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">categories</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">docker</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">gcc</span></span><br></pre></td></tr></table></figure><p>对应到(可以联想两级目录结构)：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- docker</span><br><span class="line">  - gcc</span><br></pre></td></tr></table></figure><h2 id="tags"><a href="#tags" class="headerlink" title="tags"></a>tags</h2><p>文章的标签，一般认为，<code>tags</code>并不和<code>categories</code>用法一致，它被用来标识文章中具有的知识领域，并用类似网络用语中的<code>关键字</code>来标记出来，构成另一个利于查找的维度。</p><p>由于是<code>关键字</code>一样的例子,你当然可以随意添加，但一定要实事求是。</p><h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>显示在首页中和文章顶部的摘要信息，格式为：（虽然在<code>Front-Matter</code>添加 <code>description</code>也可以，不过并不推荐，文章的markdown显示效果并不好）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">摘要</span><br><span class="line"><span class="comment">&lt;!-- more --&gt;</span></span><br><span class="line">正文</span><br></pre></td></tr></table></figure><p>（不推荐）也可以使用<code>Front-Matter</code>格式：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">这是标题</span></span><br><span class="line"><span class="attr">descriptino:</span> <span class="string">这是摘要</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h2 id="文章内图片引用"><a href="#文章内图片引用" class="headerlink" title="文章内图片引用"></a>文章内图片引用</h2><p>引用本地和外网资源图片，格式如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![](/images/example.jpg)</span><br><span class="line">![](https://static.zkqiang.cn/example.jpg)</span><br></pre></td></tr></table></figure><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码段请以<code>```</code>符号括起来，并在开头标注代码所属语言，可以根据喜好添加缩进，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 类似这样</span></span><br><span class="line">​```python</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure><h2 id="其他扩展内容"><a href="#其他扩展内容" class="headerlink" title="其他扩展内容"></a>其他扩展内容</h2><p><code>hexo butterfly</code>主题有很多扩展的选项，请参考<a href="https://butterfly.js.org/posts/dc584b87/">这里</a></p>]]></content>
      
      
      <categories>
          
          <category> 本站文章书写规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 格式 </tag>
            
            <tag> 书写规范 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
